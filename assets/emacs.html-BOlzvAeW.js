import{_ as t,c as a,a as o,o as i}from"./app-DUCnD5ZL.js";const n={};function s(r,e){return i(),a("div",null,e[0]||(e[0]=[o('<h1 id="emacs-the-editor-for-the-ages" tabindex="-1"><a class="header-anchor" href="#emacs-the-editor-for-the-ages"><span>Emacs, the editor for the ages</span></a></h1><p>This is a blog post dedicated to my, and many other people&#39;s favourite text editor. In-keeping with the theme of this section, I shall mainly focus on the misunderstood nature of the editor, and my personal connection to it. Most of it is going to be in the negative light, so it slightly edges out being posted in the Software section.</p><p>Without further ado.</p><h2 id="about-me" tabindex="-1"><a class="header-anchor" href="#about-me"><span>About me</span></a></h2><p>I feel like a hostage. This is not something that I can ... for lack of a better word admit to lightly. Emacs is a tool that I&#39;ve invested into heavily. The problem is however that I have some long-standing pain points that I hope can someday be addressed.</p><p>Fortunately to the faithful of the church of St. Ignucius, this is not going to change what environment I will daily drive. I shall not switch away from Emacs, that&#39;s kinda the point. But in this document I shall attempt to elucidate why I chose to use it, why it&#39;s a somewhat unhappy marriage, and what I&#39;d like to change to the extent of my ability.</p><p>So without further ado.</p><h1 id="what-emacs-is" tabindex="-1"><a class="header-anchor" href="#what-emacs-is"><span>What Emacs is</span></a></h1><h2 id="emacs-is-an-editor" tabindex="-1"><a class="header-anchor" href="#emacs-is-an-editor"><span>Emacs <em>is</em> an editor</span></a></h2><p>So what is this mysterious editor? Or should I say operating system!</p><p>Well, to be quite honest, I would probably disagree with both assessments. Hell, I have some notes on calling it an Emacs lisp interpreter, especially on the <code>nativecomp</code> branch.</p><p>I should perhaps qualify what Emacs <em>is</em> first, though. Emacs is Swiss army knife. It&#39;s main purpose is acting as a text editor, hence the name: Editor Macros. But it has other functions, which are, in true Swiss army knife fashion, there if you need them, but actually not at all great. One would think that this makes the Swiss army knife quite situational, but it can make for one particularly minimalist set-up capable of doing a lot in properly skilled hands. Most of Emacs&#39; prowess stems from the fact that it is a relic of a wholly different epoch of computing, which has not eschewed and in fact, welcomed the modern day, a microcosm of Unix-like operating systems.</p><p>What is particularly important in understanding why most people would deny that Emacs is a text editor. When the editor was re-written from an earlier version by Richard Stallmann, he applied the principles that he had to have inherited from his Computer Science background; he thought ahead and created progressive layers of abstraction[^1].</p><p>So how does it work? Emacs, when compared to a pure text-editor, such as <code>nano</code>, or <code>vi</code> is extensible. So if what you do is a bit more involved than say editing a single config file, or you&#39;re doing programming and having some more automation is useful to you, then Emacs offers a compelling package. The editor relies on a combination of muscle memory, precise typing and some occasional customisation to enhance the programmers natural ability to produce large amounts of text: (I heard that programmers have to produce a large amount of code in the form of text every day). The consequence of this, is that the programmer &quot;can work in Emacs faster than most people can think&quot; (source Primagean).</p><h2 id="dialogues-with-the-user" tabindex="-1"><a class="header-anchor" href="#dialogues-with-the-user"><span>Dialogues with the user</span></a></h2><p>Well, Emacs isn&#39;t your typical graphical program, that tries to abstract away the internals, and hide the inner workings. No, Emacs breaks down basic editing into functions, which the user is encouraged to know about. Like the venerable and extremely useful <code>ed</code> editor, Emacs defines a language for factoring editing into function calls and interactive text input. In principle every act of editing a piece of text comes down to this in every editor, but with <code>ed</code> the commands had to be written out explicitly and the interface more resembled a REPL, than a modern editor. Of course, Emacs does the same, but with a twist. If <code>ed</code> wants the verbs to remain largely implementation-defined and the user is encouraged to factor the editing process into this <em>complex instruction set</em> of operations, Emacs takes a more <em>RISC</em> approach. There&#39;s a bunch of core functionality that&#39;s implemented in C, but a lot of the functionality is implemented in Emacs lisp. The user is encouraged to write more verbs, to experiment with the transparent hook system, and to write packages, which can then be re-used. The program emerges from binding the functions to inputs, so the user can in principle override the way in which certain commands operate, in stark contrast to how <code>ed</code> operated. An additional difference from the <code>vi</code>-family was that Emacs allowed the user to define their own functions, via a configuration language, Emacs lisp. This, true to the spirit of collaboration in the academic environment led to the creation of a multitude of packages, ranging from an implementation of tetris (which is now shipped by default), to various packages designed to majorly enhance a particular kind of interaction with a particular variety of text files.</p><p>This spawned a particular popularity amongst programmers, though Emacs&#39; uses were not confined to programming[^2]. Emacs allows programmers to solve text editing problems in a familiar fashion to the way they program, but allowing them to eschew having to fork a text editor that they built from source, but rather writing a compact Emacs lisp function, marking it as <code>interactive</code>.</p><p>Emacs, allowed programmers to go beyond simple text editing. But how does Emacs managed to capture the eyes of those looking for an integrated experience? IDEs after all, are both able to support plugins, and designed to provide users with a more feature-full experience of interacting with their programming environment. The answer is relatively simple.</p><p>Most programming is done in a relatively straightforward fashion: one has a plain-text file with a funny extension. While it&#39;s possible to write your C++ code in a <code>txt</code> file it is not exactly encouraged, nor a good idea. It is often the case that one has come up with a programming language, and had used a plain text editor to edit the source code. As such, while it could be possible, in principle to produce an extension for Eclipse, Geany or KDevelop with a similar amount of effort, to produce an Emacs so-called major mode is often far quicker and easier, at the cost of perhaps, being less efficient and feature full. A lot of the time, this comes down to there being syntax definitions for highlighting, and that&#39;s really about it. If your language makes use of common sense ideas, such as the C-approach to identifiers, and using matched parentheses, odds are, the target audience already has a plugin that handles those things, and complicated heuristics are unnecessary.</p><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples"><span>Examples</span></a></h2><p>Emacs had a Rust major mode for a good part of Rust&#39;s existence. It is still not perfect, mind you, but it is a fully-fledged syntax highlighting plugin that made interactions with the source code easier. IntelliJ have only recently produced an IDE, that I would probably rank as on-par, though with some glaring omissions. The reason? It is much easier to knock out a parser for a formally defined language in what already resembles the definition of the grammar in some computer science courses, than it is to extend largely monolithic code bases like IntelliJ idea.</p><p>So, in effect, Emacs is the trailblazer of the approach that is ubiquitous today. I will not argue that its execution is the best, or that it is by any means a perfect approach, but I will now discuss why my attempts to move away from it have, thus far, been unsuccessful, thus demonstrating further the positive aspects of this editor.</p><p>But there are other good things.</p><h1 id="major-alternatives" tabindex="-1"><a class="header-anchor" href="#major-alternatives"><span>Major alternatives</span></a></h1><h2 id="a-return-to-the-roots" tabindex="-1"><a class="header-anchor" href="#a-return-to-the-roots"><span>A return to the roots</span></a></h2><p>Going back to the <code>vi</code> family of editors is perhaps the most viable option for me.</p><p>This is largely to a horizontal gene transfer that took place between the two: editors over the years.</p><p>NeoVim has perhaps the most appeal to me, and could confer <em>some</em> advantages.</p><p>But here&#39;s where I find it not to be compelling option yet.</p><p>Emacs&#39; greatest strength stems from being a graphical program. In principle, though sadly not in practice, this would mean that more things than just plain text entries with mono-spaced fonts can be utilised in the creation of graphical interfaces. Indeed this had been somewhat remarkably demonstrated by the eponymous <a href="https://github.com/rougier" target="_blank" rel="noopener noreferrer">Nicholas P. Rougier</a>, who has toiled relentlessly to create a visually appealing version of a text editor that looks decidedly outdated by default. This means that hopefully, some time later, it should be possible to do a WYSIWYG style of editing effortlessly in Emacs. Indeed, this is possible already in principle using some trickery and <code>org</code> mode, but far from seamless.</p><p>Unfortunately, I don&#39;t see this happening with NeoVim anytime soon. It is relatively easy to add this functionality to NeoVim, but this is liable to lead to a further fragmentation. Certainly there could be plugins that are specific to specific front-ends, but architecturally, NeoVim is decidedly a terminal-based application and it will remain that way for the foreseeable future.</p><p>Aside from that, NeoVim has not a lot to offer that Emacs doesn&#39;t already do within margin of relevance. For example, NeoVim might have a slightly better implementation of intellisense than Emacs, but it doesn&#39;t matter to me, because my workflow is to prompt the program for completion actively, and not wait for a menu passively, and here NeoVim has no equivalent of <code>embark-act</code>. Similarly, while <em>e.g.</em> the NeoVim project has a list of official front-ends, they are in no way equivalent. NeoVide is an interesting take, with some flashy animations. Due to architectural restrictions that&#39;s the extent of it.</p><p>There&#39;s a case that goes both ways for the configuration language. On the one hand, <code>lua</code> is a much easier language to work with, in terms of more people knowing it, and its syntax being far less intentionally annoying. However, there the advantages of <code>lua</code> are exhausted, and the appearance of a new kid on the block – <em>tree sitter</em>, would allow Emacs to flex its lisp muscles.</p><p>Make no mistake, programming in Emacs lisp is challenging, doubly so because of the decision to not provide some information at the necessary level. The sheer fact that I cannot be sure that a Lisp file is error free until I evaluate it, and that simultaneously, if it is not, I get next to no useful information in the error message, makes me wish I had access to <code>lua</code> or <code>Python</code> for configuration. Still, those problems are in the minority, and once fixed – a distant sour aftertaste, rather than a deal-breaker. The fact that there would be more <code>lua</code> code per configuration is a problem though, one that has to be fixed in one way or another.</p><p>Everything else, including modal editing, can be replicated in Emacs. Though I must say that not having to worry about which mode I am in, has made me a better editor, though perhaps not a faster typist.</p><p>In a straight comparison, the way I would write this document in <code>neovim</code> would be mostly identical to how I would write it in Emacs. With one key difference. If I were to edit it in Emacs, I would not worry which mode I am in, thus allowing me a more usual experience. Similarly, my wife would be able to use this as well, since she is familiar with how most similar text fields work on every other operating system. With modal editing another quirk is introduced. And I found it to be easier never to use modal editing, than to have to context switch between text input in the browser and how it&#39;s done in the terminal (assuming I&#39;d even use the vi-bindings for the command-line which are just irrationally stupid).</p><p>So the <code>vi</code>-family is out.</p><h2 id="atom-eee-edition" tabindex="-1"><a class="header-anchor" href="#atom-eee-edition"><span>Atom EEE edition</span></a></h2><p>This point is not clear cut as one might think.</p><p>I&#39;m a vocal opponent of the usage of this program, but I don&#39;t think that most of this is well-justified and well-intention&#39;d.</p><p>The reasons I hadn&#39;t touched <code>code</code> up until now and for some time in the future potentially are as follows:</p><ul><li>I really liked Atom, and I don&#39;t like the idea of it being embrace-extend-extinguish-ed.</li><li>I don&#39;t like Electron and <em>most</em> (see above) applications built with it.</li><li>I don&#39;t like Microsoft products and try to avoid them. I don&#39;t use Windows, I void Microsoft&#39;s office suite, despite being very good at using it.</li><li>Everyone&#39;s using VSCode and being a contrarian is cool.</li><li>I have had an irrational fear of JavaScript. Not having overcome it postponed the launch of this site, and made my work harder in many respects.</li></ul><p>The moment I realised these points were irrational, was when I considered that they would equally apply to the text editor that I like:</p><details class="hint-container details"><summary>Emacs</summary><ul><li>Emacs didn&#39;t start life as an open source editor. Richard Stallmann made it so, but it was not so initially.</li><li>I don&#39;t like GTK much either. The list of GTK applications that I use is just as thin, if not thinner than that of electron apps.</li><li>While I like some of the principles espoused by the FSF, the <em>only</em> application that I like that is totally aligned with the FSF goals <em>is</em> Emacs. Politics should not have anything with the choice of tools. It should influence how I use those tools.</li><li>Being a contrarian can give you a wider perspective, but only if you don&#39;t limit yourself to the stuff that everybody likes. Plus, <em>many</em> of the reasons why I used <code>vi</code> and eventually Emacs has to do with the herd mentality of trying to fit in with the &quot;cool kids&quot; at university.</li><li>Emacs lisp is just as bad, if not worse than JavaScript in some aspects. This has many reasons and many implications. And according to <a href="https://www.oreilly.com/library/view/javascript-the-good/9780596517748/" target="_blank" rel="noopener noreferrer">Doug Crockford</a>, the languages share more in common than anyone familiar with either language will let on.</li></ul><p>VSCode is a modern take on Emacs. It is not all that different. I would need to try it before I criticise it. Not because I owe Microsoft the benefit of the doubt, but because I owe my audience an informed opinion, and at present I don&#39;t have one.</p></details><details class="hint-container details"><summary>Vim</summary><ul><li>Vim is a descendant of a collection of editors, with a proud history of being attached to the original Unix, which contrary to popular belief, was not the epitome of free software, until things like the GNU project.</li><li>I positively hate terminal applications that pretend to be GUIs. I positively hate the idea that we&#39;ve messed up graphical programming to such an extent that it is easier to make a terminal application, with cruft retained from the teletype era, be portable than an unencumbered program using <em>e.g.</em> SDL.</li><li>The Unix philosophy is overrated. NeoVim is a good example of why you&#39;d need to replicate the functionality of something like <code>tmux</code> to make things comfortable.</li><li>Using <code>vi</code> instead of <code>nano</code> is a symptom of some well-intentioned person mentioning that <code>vi</code> is &quot;more advanced&quot; than <em>e.g.</em> <code>gedit</code>, <code>kate</code>, <code>nano</code> <em>etc.</em> There&#39;s a lot of herd mentality involved in choosing <code>vim</code>.</li><li>VimScript is a terrible language. Emacs lisp is a problem-laden mess, it is without a doubt the worst lisp, but it is nonetheless a keen language, with many interesting features. It has similar problems to JavaScript, and a misleading similarity to C. VimScript does not have such luxury. Though this comparison should include Lua, I think it would win.</li></ul></details><p>However, it is unlikely that I will stick to it. I don&#39;t like writing proprietary software, dealing with proprietary software and helping ecosystems that have an explicit goal of making open ecosystems worse. I will be inspired by some things that I see in VSCode, and maybe adjust my workflow, but I will not be a &quot;productive member of the VSCode &quot;&quot;&quot;Community&quot;&quot;&quot;&quot;.</p><h2 id="kakoune" tabindex="-1"><a class="header-anchor" href="#kakoune"><span>Kakoune</span></a></h2><p>This is an interesting and more visual take on the <code>vi</code>-style modal editing. It retains much in common, but with a twist. It is remarkable in many ways, and I tend to use it in scenarios where I used to use <code>vi</code> or <code>vim</code>.</p><p>It has some genuine advantages: built-in LSP support, out-of-the-box syntax highlighting, an arguable improvement to the verbs of <code>vim</code> (though my opinion is the only one that matters here), and it&#39;s easier to type <code>kak</code> than it is to type <code>vim</code> or <code>nvim</code>.</p><p>Kakoune is opinionated, but in the right way, it caters to a specific use-case and in many ways scratches an itch that almost everyone that was learning <code>vim</code> in their teens would have.</p><p>One problem I <em>used</em> to have with Kakoune, was the assumption that the program would not need/have a scripting facility, and no way of defining custom/new verbs, like the old <code>vi</code>, but unlike <code>vim</code>, and many of the modern editors. This has thankfully been addressed and there&#39;s a heap of plugins for Kakoune. No curated list as of yet, but this might change in the future.</p><p>All else being equal, it is a direct upgrade to <code>neovim</code> in many ways except one: it still falls into the trap of using a customised language called <code>kakounescript</code>. It is a strong contender, and definitely something that I will be using, if not full time, then at least in some capacity.</p><div class="hint-container info"><p class="hint-container-title">helix</p><p>Helix is a direct downgrade to Kakoune in many ways. The only saving grace is that they chose to &quot;rewrite it in Rust&quot;, but that is only a positive in some cases.</p></div><h2 id="focus" tabindex="-1"><a class="header-anchor" href="#focus"><span>Focus</span></a></h2><p>I will not lie, Focus is a very strong contender. It has many features going against it, and a few going for it, but it is also an editor in its very early stages of development, so here&#39;s hoping.</p><p>Focus&#39; main weakness is the absence of a scripting language similar to Emacs lisp. This weakness is compounded by the fact that it is written in Jonathan Blow&#39;s as yet unreleased Jai programming language, that requires one to enter a closed beta to gain access to a compiler. The code is clean and easy to understand, despite being in a language that I&#39;m not familiar with, a credit to both the language, and the editor.</p><p>It is a keenly interesting editor in a few aspects, it has good performance and is largely easy to deploy/manage on account of being a statically linked executable with batteries included.</p><p>The number of included batteries is not as much as you&#39;d hope. There&#39;s no markdown highlighting support. I respect that; markdown doesn&#39;t exactly <em>need</em> highlighting. But there&#39;s also limited highlighting for files that should not be considered esoteric; this site is (at present, at least), built using <a href="https://vitepress.dev/" target="_blank" rel="noopener noreferrer">vitepress</a>. The config file is a file called <code>config.mjs</code>. Not only do I not have automatic error checking as I do with Emacs, not only do I not have the convenience of being able to just run compilation and jump to the error; I don&#39;t even have the decency of having some syntax highlighting. JavaScript? Yes sure, but not M-JS. So it&#39;s not as complete as one would like, but you can also see that changing once the editor gains some traction.</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>We&#39;ll come back to this later when discussing <code>lem</code></p></div><p>The editor, once you&#39;ve gotten the compiler from the closed beta is fairly straightforward to compile and test, and as I discovered to hack into. It is also very easy to deploy, there&#39;s a single static executable, and almost nothing is linked against dynamically (not even the <code>libc</code>). A lot of its success can be attributed to Jai, despite Jonathan Blow having not been involved in the development of focus, he&#39;s keenly influenced some of its design decisions.</p><p>But what do I make of the rest of the editor. I&#39;m less productive. Unlike editors written in Rust or C++, the ways in which a Jai program can misbehave are not yet well-known and sometimes not the fault of the programmer. I miss being able to trim white space in one command. I&#39;d love to see the function be introduced at some point, but I don&#39;t personally have the time to create a pull request and hope that it gets merged. I&#39;d like to eventually have LSP support. It&#39;s much harder to implement that, on account of the fact that Jai doesn&#39;t have much code written in it yet, to compare how one would connect to a server and respond to its feedback. It is hard to even consider things like Copilot integration, or more advanced features. While Emacs made LSPs redundant in a way, by allowing one to do much more thanks to the fact that it&#39;s a complex web of built-in packages that are doing some amazing things (<code>project</code> and <code>projectile</code> come to mind), you don&#39;t usually have the need to worry about much. Sure Emacs doesn&#39;t have native collaborative editing support, but it has <code>crdt.el</code> which is the next best thing, and trivial to set up, even when you&#39;re behind a NAT. With Focus most of this is much harder to do.</p><p>As of today, switching to it full time, is non-viable, unless I wanted to do some form of challenge. But I can foresee contributing to it, and using it, and writing some form of extensions to it.</p><h2 id="kate" tabindex="-1"><a class="header-anchor" href="#kate"><span>Kate</span></a></h2><p>This is an editor that <em>might</em> have been dismissed by many as not exactly even in the same league as the others. I found that assertion to be true, but in the opposite direction. Kate has an uncanny ability to match Emacs&#39; feature set, in a package as appealing as that of VSCode, and at the same time, having none of its drawbacks, irrational though they may be.</p><p>Firstly, Kate is a long-established project with a healthy ecosystem. It is not, like the other editors on this list a facsimile of Emacs, it only happens to cover most of the same ground, but with <em>very</em> different backbones and has a much higher potential ceiling.</p><p>Firstly, the editor out of the box, covers most of what I would need from a code editor: I don&#39;t need to spend a significant amount of time digging through other people&#39;s configurations to get into the state of usability. It highlights markdown and org out of the box, it has LSP and DAP integration, and actually does them well: I don&#39;t need to install a package and <em>hope</em> that it will work, it happens to come in a working state. Considering that Kate is a KDE project I find this to be a fascinating achievement, most of their other projects... ahem... KDevelop... ahem... are nowhere near as stable. This is quite exciting because for the life of me I couldn&#39;t figure out why <code>company</code> pretends to not have any completion candidates half the time, and is dog slow the other half. Kate by contrast has a similar function to Emacs&#39; <code>dabbrev</code>, though the implementation is decidedly more akin to modern solutions, losing some of the charm/lustre. Kate has syntax highlighting for esoteric things, like for example StandardML. It didn&#39;t a while ago, back when that would have been helpful. It is fast, on account of using a highly optimised native toolkit, and has a healthy ecosystem of libraries and packages; it&#39;s a KDE program after all.</p><p>The debugging is good, and sidesteps new fads (such as displaying values of variables next to them, rather than in a neat table), and it crucially has support for sequential key binds. I can attach <code>Ctrl-x Ctrl-s</code> to save, and it will save. It can work with a mouse, I can drag blocks of code around, set breakpoints, and fold headings. I have an inordinate amount of visual feedback whenever I do something as simple as enter a delimited block. It does inlay hints and does them well. It can change the font in your editing window, without having to muck around trying to find if what you typed has a mistake in it. It can do visual elements for things that ought to have visual elements, like e.g. Git history. It can show a sane diff, and can resolve conflicts without you having to use the dreaded (and in my opinion not particularly good) <code>smerge</code> package. Its built in git client isn&#39;t as good as <code>magit</code>, but there&#39;s no reason why it can&#39;t be made better. It has somewhat of a similar idea to the IntelliJ offerings in terms of how you&#39;d do a compile/build/deploy, but that is not a problem, because you can just hit <code>F4</code> and get a terminal. If you get feedback in terms of diagnostics, they&#39;re categorised, and navigable, just like in Emacs. Unlike Emacs, they&#39;re navigable even if you don&#39;t use the <code>flycheck</code>/<code>flymake</code> packages and/or explicitly use a <code>compile</code> command whose output may or may not parse correctly. It defaults to soft tabs. So what else do you want?</p><p>Well, frankly, not much, but those things will make life unbearable when they come up. Firstly, I intend to write a lot of Jai code. In Emacs, it is trivial to knock out a major mode for a language that has some similarities to the C-style languages, one of a few places where inheritance is a good thing. In Emacs, due to manifold exploration opportunities, I&#39;ve experimented with different code highlighting/typesetting systems. What this lets me do is do some crazy things which are not that crazy when you think about them: having the height of headings be bigger, instead of just being a different colour, allows me to use colour in an orthogonal fashion. I can highlight text with a different typeface: set things in <code>sans</code> and <code>serif</code> when I need to. I can also use the information that is already gleaned from the parser to do other things, like contextual commands. Emacs&#39; <code>embark</code> command is perhaps one of the best examples of this. Vim might not have this, but in Kate, something like this would be prohibitively difficult to implement.</p><p>Another thing which I&#39;m missing in Kate is the modularity of Emacs. Most Emacs packages are self-contained, and they integrate only with Emacs. In Kate everything is tightly woven, even though technically it shouldn&#39;t be. Even the Kate packages that are considered to be plugins do not exist in separate repositories. This might change in the future and make my life a bit easier, but unlike with Focus, where the potential is obvious and immense, with Kate, this is likely to happen at a glacial pace.</p><p>I want to be able to embed a Qt application as a window into the editor, and have it <em>just work</em>. Maybe I&#39;ll need to fork Kate for that architectural change, and maybe I will need to write something from scratch to do it. But the core idea of there being mainly components that are abstracting away some of the aspects of the interaction in a consistent fashion is why I find Kate to be so appealing. It doesn&#39;t fight the CUA standard, it just allows one to side-step it if they need to. But it doesn&#39;t allow the editor to be your canvas, and experiment and tailor your editor to your workflow.</p><h2 id="lem" tabindex="-1"><a class="header-anchor" href="#lem"><span>Lem</span></a></h2><p>Lem is probably the final contender of which I don&#39;t know what to make of. It is an editor that, if accomplished, has the potential to be a direct upgrade to Emacs, and to make this problem go away. But it is also somewhat esoteric.</p><p>Hear me out. One of the key advantages of <code>lem</code> is the fact that Emacs is only configured in a lisp, but <code>lem</code> is written in its entirety <em>as</em> a lisp program. So, as something that is both of the Emacs heritage, and simultaneously free from its technical debt, Lem can do things better. An Emacs user feels at home, knowing that <em>e.g.</em> <code>C-a</code> jumps them back to the beginning of the line, and <code>C-e</code> to the end of it. There are ways of configuring it to feel like my Emacs config, assuming I can port over the functionality that&#39;s missing.</p><p>In principle <code>lem</code> is an opportunity to fix Emacs&#39; long standing issues, without also making the users of the old Emacs unhappy. It is the <code>vim</code> of the Emacs world. And given that similarly to how <code>nvim</code> fixed VimScript, <code>lem</code> can rely on Common Lisp to provide most of the advantages and none of the drawbacks of Emacs lisp, it makes sense to consider it.</p><p>Unfortunately, <code>lem</code> makes some crucial mistakes, early on. They have the potential to completely nullify the advantage that Lem might have over Emacs.</p><p>First and foremost, it&#39;s designed around a terminal UI. It doesn&#39;t and didn&#39;t commit to a GUI-only approach that Emacs did, which is perhaps the biggest blunder of the program&#39;s designers. This means that almost every critique I can levy at Kakoune and Kate for not supporting my insane workflows mixing different proportional typefaces counts double. If you want to target the official <code>lem</code>, you are going to target the terminal version... Which means that none of the GUI stuff gets done, not now, not later, not eventually. This is painful. One thing that has to be done in a hacky way on Emacs, are the GUI elements in things like <code>customize-apropos</code>, instead of having an actual text-box, you are given an approximation of what a DOS-era text box would look like, except less useful and more shitty. The reason for this is the separation of the GUI toolkit of Emacs -- GTK and the run-time nature of interpreting E-lisp, even if it&#39;s compiled to a dynamic library in native binary. It was decided to go function over form, which later ended up just choosing not to have decent-looking controls. In Lem, given it uses SDL, not only can those controls be done better from scratch, most of the technical limitations which would prevent one from using this stuff correctly are also gone. But, in a typical &quot;you had one job fashion&quot;, because the main target is a terminal implementation, people targeting Lem, will almost never support the GUI features...</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>TELETYPES ARE FUCKING DEAD; GROW THE FUCK UP!!</p><p>Make a good FUCKING GUI APPLICATION. Nobody complains about GUIs if they&#39;re done right. If you don&#39;t know how to do it, leave room for someone who does.</p></div><p>Minor annoyances abound, though not in and of themselves deal-breakers. All the functions that I&#39;m missing can be ported, and ported easily I must add, because the languages are fundamentally compatible. The bigger question is: &quot;would it be harder to adjust Emacs to what I&#39;d like it to be&quot; as opposed to adding what&#39;s missing to <code>lem</code>? And I frankly don&#39;t know. It might go either way.</p><p>I find editing in it less comfortable than any other editor at the moment; the main reason is that I found that it has enough in common with Emacs to lull me into a sense of familiarity, but not enough to make me actually accurate. Case in point, I have a nasty habit of pressing <code>M-q</code> to fill text to the 60 column mark. In <code>lem</code> this is equivalent to closing the window. Oh and by the way it inherits the outdated (and extremely confusing) nomenclature from Emacs.</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>AT LEAST COPY THE FUCKING THINGS THAT ARE FUCKING GOOD!</p></div><p>Clearly a long way to go, but given that this is largely a community driven project, it&#39;s a toss-up. It has a chance, much more than <code>helix</code> does, but it needs something more than just an advantageous position.</p><h2 id="lite" tabindex="-1"><a class="header-anchor" href="#lite"><span>Lite</span></a></h2><p>I frankly never used it before. It is probably what NeoVim would do for me, if it were any good, but it comes with some creature comforts that I like quite a bit. To me Lite does what a text editor should do. I quite like <code>lite-xl</code> and might use it if I get the chance. It is definitely not as well-supported as Emacs, and definitely not as widespread as <code>neovim</code>. Still it has a chance, so I&#39;ll give it one.</p><p>As a purely text editor, it does well. It doesn&#39;t come with LSP support, and while I appreciate the ability to configure the editor using a GUI, that is also something that Kate can do, and in my opinion much better at that.#</p><p>Still I know people that use it, and today I found out why.</p><h2 id="not-even-bad" tabindex="-1"><a class="header-anchor" href="#not-even-bad"><span>Not even bad</span></a></h2><p>If you are not familiar with the expression &quot;not even wrong&quot;, you might think that these editors are OK. They&#39;re not. In fact, they&#39;re so terrible, that they cannot under any circumstances be considered for a replacement. I will detail how bad each of them is, but try to reserve particularly harsh critique in the appropriate <code>warning</code> segment.</p><h3 id="lapce" tabindex="-1"><a class="header-anchor" href="#lapce"><span>Lapce</span></a></h3><p>Do buzz-words give you a buzz? You&#39;re in luck! This wonderful editor manages to look older than Emacs. More buggy than Emacs on Wayland. Do you like Rust? Do you like Web Assembly? Are you an idiot? Lapce is for you.</p><h2 id="scite" tabindex="-1"><a class="header-anchor" href="#scite"><span>scite</span></a></h2><p>This project should die already. It has no discernible reasons to exist other than if you are running a super-minimal setup and are not very intelligent, that you might delude yourself into thinking that it has fewer dependencies.</p><h2 id="pulsar-atom" tabindex="-1"><a class="header-anchor" href="#pulsar-atom"><span>Pulsar/Atom</span></a></h2><p>I&#39;m sorry but no. It might be that the people were not <em>entirely</em> stupid when they were designing Atom, but I don&#39;t think this has anything remotely approaching a chance. Most of its suggestions are counter-productive, its only saving grace is that it is compatible with VSChrappium extensions. It tries really hard, but unlike Kate, it doesn&#39;t do all that well. I&#39;m willing to forgive that it&#39;s based on Electron and looks like crap despite that. I&#39;m willing to forgive that it&#39;s slow, based on the former acknowledgement. I cannot forgive that it is so FUCKING convoluted that simply opening a single markdown document takes me longer on Hyper with no extensions than it does loading my extremely heavy Emacs set up.</p><h2 id="sublime-text" tabindex="-1"><a class="header-anchor" href="#sublime-text"><span>Sublime text</span></a></h2><p>I&#39;ll say this, I&#39;ll use it if I have to, and if the alternative is GEdit. But in my opinion, it&#39;s not particularly great. It had years of development, and is decidedly behind things like <code>neovim</code> and Emacs. Fewer functions, an ageing cross-platform toolkit that is not great, but not nearly as bad as electron. If Kate didn&#39;t exist, Sublime would have been something I would consider, but unfortunately, a team more concerned with providing a basic text editor did a better job making sure that the LSP worked, than Sublime did. And they have no execute. If you ever worked on a KDE project, you know that the code-bases are often extremely difficult to navigate and operate on. With Sublime having a much smaller code-base and having funding to warrant the development of the project, I have zero confidence in the project. It is a one-trick pony. That trick is now a basic requirement for command-line editors like <code>kakoune</code> and <code>helix</code>.</p><h2 id="vschrappium-also-known-as-vscodium" tabindex="-1"><a class="header-anchor" href="#vschrappium-also-known-as-vscodium"><span>VSChrappium (also known as VSCodium)</span></a></h2><p>The epitome of the naivete of us humans. This is probably the best example I can point to, when I say that pussy licenses are dumb, that the Open Source software development model is broken beyond repair, and that we should emphasise whether software is Free as in Freedom, or just open source.</p><p>Suppose I were a free software in everything evangelist. What problems does VSChrappium address that I would have? For one, let&#39;s suppose that I have an ideological problem with Microsoft pushing its proprietary editor. By using the open source counterpart, I&#39;m still helping it <em>extend</em> the open source with their ideological approach (of &quot;just use VSCode&quot;). I&#39;m cutting out the telemetry, true, but I&#39;m also given the impression that the proprietary extensions make this an incomplete package. Nobody mentions the VSChrappium, they mention VSChrap support. And the greatest thing about it, is that the licensing terms mean that if you contribute code to the project, they can take it and add my code (that was contributed to VSChrappium) and it to the proprietary counter-part.</p><p>If you care about free software, and like to use VSChrap, then</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>JUST FUCKING USE VSChrap!</p><p>Let VSChrappium FUCKING DIE! BE HONEST ABOUT WHAT YOU&#39;RE FUCKING DOING!</p><p>AND SHUT THE FUCK UP ABOUT IT BEING OPEN SOURCE!</p></div><p>::: error If I&#39;m committing the crime of using a Microsoft product and allowing it to establish yet another monopoly, I might as well take away the thing that lets me engage in intellectual dishonesty. :::</p><h2 id="acme" tabindex="-1"><a class="header-anchor" href="#acme"><span>Acme</span></a></h2><p>To keep myself intellectually honest, I&#39;ve written each segment in this document in the editor that I was referring to.</p><p>There was one editor so utterly broken and misguided that no matter how many variations of it I tried, I could not get it to work.</p><p>I assure you, there are plenty of commentaries on the original package, but given that I was comparing Emacs to the <em>current</em> state of <code>vi</code> namely <code>neovim</code> and comparing Emacs to the original Acme would have been utterly unfair, I will reserve critique until I can get any of them running.</p><p>Not a huge fan of how things turned out, because I was ready to go on a long tirade about how utterly misguided the entirety of plan9 was, but fortunately for plan9, their software doesn&#39;t even run.</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>You suck-less buffoons should consider making your programs ACTUALLY SUCK LESS, INSTEAD OF WRITING ABOUT IT!</p><p>IF YOU HAVE TO <strong>SAY</strong> that your programs SUCK LESS, then you&#39;re probably part of the problem.</p></div><h1 id="appendix-in-the-beginning" tabindex="-1"><a class="header-anchor" href="#appendix-in-the-beginning"><span>Appendix: In the beginning</span></a></h1><p>Why did I end up on Emacs?</p><p>Peer pressure mostly.</p><p>I&#39;d say mostly, because the purple <em>E</em>, was something I was always curious about; it showed up as a keybindings scheme in Gnome Tweak tool (that incidentally did nothing) it was a &quot;lightweight&quot; text editor that promised to be on par with what I was used to, but I never really took the plunge? Why?</p><p>I was (quite honestly), content with using Vi. Yes, not even vim, just vi. I could even trace the evolution of what I used for text editing through the following curious (perhaps not to many) path.</p><p>At first, I was using just plain old Word &#39;98 for anything that was prose adjacent. It had some quirks and I had to resist the urge of inserting WordArt, knowing full well, that the result would look different. But it was fine. I lived in a world in which text and plain text meant the same thing. I knew of a time when we used DOS, and I knew that it was mostly text based, but the only program I can distinctly remember from those days is <code>nc</code>.</p><p>At some point I had to learn how to program, and my first, and not-quite serious foray into programming was using MS Visual Studio 98, a copy of which I inherited from my Dad (he was rubbing his hands with nostalgia and anticipation, because prior to this I showed no interest in understanding how computers work, beyond games). The IDE experience was the main means of interaction, where soon I learned that a project was just a shittier version of a single <code>.cpp</code> file, that I could in principle just write those and compile them directly. I didn&#39;t understand what the header files were for and I assumed that large programs were simply a large single text file with no organisation beyond forward-declared functions. Oh and don&#39;t get me started on the command line.</p><p>This was, for the most part, how I viewed the computing world for most if not all of my early days. Even to the point, that despite being reasonably good at Physics, I was content with this sort of complete misunderstanding how computers worked and how software is built.</p><p>At that time I started dabbling in GNU Linux, but not in a serious capacity. The most I did was install some games through wine (back when that was a true challenge), and perhaps installing Arch was what gave me some challenge. I learned to use <code>nano</code>, but also to despise it with a passion. On the other hand, in Windows, there was Skyrim and I started modding it using… ahem… NotePad++. And I liked it quite a bit. It&#39;s definitely something that in retrospect wasn&#39;t terribly advanced, but I didn&#39;t exactly need something advanced. The sheer fact that I took an entire month to write prose pretty much continuously was what I did, and it wasn&#39;t exactly a problem.</p><p>But at some point the elitist Arch-bro had to be born, so I had to learn the advanced editor. So I did… Vi was that. And I didn&#39;t switch for the longest time. <code>vim</code> was <em>an</em> improvement, but Bram Moolenaar (god rest his soul) didn&#39;t make it <em>the definitive improvement</em> over Vi. And besides, I didn&#39;t really write programs all that often, mostly config files, so <code>vi</code> was frequently only used to write config files on a bog-standard GNU+Linux system. And at around 2015, when I finally stopped distro and desktop hopping (and nuked my final install of Windows), I completely settled on using <code>vim</code>.</p><p>At this key moment, I often had used other graphical text editors, but the sheer beauty of <code>vi</code> was its omnipresence. Almost all UNIX systems shipped with it, even if only select few even had <code>vim</code> in the repositories. I had used <code>vi</code> for most of my early days in Cambridge, but that&#39;s when I started to feel some pressure to conform to what I&#39;ve been taught.</p><p>So like in previous years, I had picked an IDE, at first it was eclipse. At some point later it was IntelliJ. Later on, though, I got an email that read roughly like this</p><blockquote><p>&lt;1&gt; Dear Students, I&#39;ll be your algorithms supervisor for the Lent term. Please start using something serious like IntelliJ, or perhaps the clever students would be using something more advanced like Emacs.</p><p><a href="Re:1">Re:1</a> But I use <code>vi</code>.</p><p><a href="Re:Re:1">Re:Re:1</a> That&#39;s certainly a choice.</p></blockquote><p>Of course this wasn&#39;t Emacs on GNU+Linux, but rather on a mac (back when macs were good). Plus, I found an irrational human being that had also aliased their <code>vi</code> to <code>emacs</code>, used <code>emacs</code> in the terminal, and what I think was perhaps the worst part of all, had a troll face mode. Fun memories, given that we had a proper hackathon (port wine and funny jokes included).</p><p>This was when I made the best decision of my life and completely ignored the advice, instead opting for IntelliJ idea, and doing my work in an environment that didn&#39;t require me to learn a third language (plus you have to keep in mind, that as a student that took a Computer Science option, I was completely reliant on the desktop computers which then provided either Windows, or a version of Ubuntu Linux)[^3]. Finally, the year that I caved in was when I decided that it would be a great idea to try Emacs on my main machine. Out of sheer peer pressure, I must add.</p><p>Of the professors I&#39;ve studied under, almost everyone praised Emacs. It was a mark of cleverness in their eyes. And there were some things that I found to be … for lack of a better word… problematic. For one, there was an air of superiority about the usage of a particular tool. I, for the first time, heard someone say something negative about Eclipse (the IDE). I had also been party to a silent understanding that while Vi-likes were the tool of choice for engineers, then &quot;real computer scientists used Emacs&quot;[^4]. Secondly, while it was a program that people used quite often to cite the power of programming, I struggled to find a way in which it <em>could</em> be better than say <code>vi</code>. The ergonomics of modal editing plus the reliance on the Unix philosophy made for compelling arguments. Usage of yet another language to configure something didn&#39;t exactly sound like a compelling argument to me.</p><p>So how did I end up with this extremely elitist piece of software, Emacs? Easy. I just wanted to see what the fuss is about, and I found it to be extremely usable. Yes, one might have expected that the love for Emacs came from Richard Stallmann, but I always found that his take of &quot;you should use X, because it supports the free software movement&quot; to be rather a mark of severe impracticality. If you recall I mentioned curiosity, well this is why I never took the plunge before.</p><h1 id="footnotes" tabindex="-1"><a class="header-anchor" href="#footnotes"><span>Footnotes</span></a></h1><p>[^1]: To us today, the presence of a Turing-complete configuration language, and the ability to install extensions for editing facilities seem obvious, largely due to this idea being incredibly prolific.</p><p>[^2]: One particularly interesting example is that of author Vernor Vinge, who uses Emacs, but is by no means known for being a programmer.</p><p>[^3]: This was perhaps the hardest part. The windows version came with Kate, did not come with <code>vi</code> and rebooting was not really an option, because it took prohibitively long.</p><p>[^4]: Of course none of this was said explicitly; like much in Cambridge it was something to be understood.</p>',129)]))}const l=t(n,[["render",s],["__file","emacs.html.vue"]]),d=JSON.parse(`{"path":"/posts/rants/emacs.html","title":"Emacs, the editor for the ages","lang":"en-GB","frontmatter":{"date":"2024-01-09T00:00:00.000Z","category":["Emacs","Work","Tooling","Rants"]},"headers":[{"level":2,"title":"About me","slug":"about-me","link":"#about-me","children":[]},{"level":2,"title":"Emacs is an editor","slug":"emacs-is-an-editor","link":"#emacs-is-an-editor","children":[]},{"level":2,"title":"Dialogues with the user","slug":"dialogues-with-the-user","link":"#dialogues-with-the-user","children":[]},{"level":2,"title":"Examples","slug":"examples","link":"#examples","children":[]},{"level":2,"title":"A return to the roots","slug":"a-return-to-the-roots","link":"#a-return-to-the-roots","children":[]},{"level":2,"title":"Atom EEE edition","slug":"atom-eee-edition","link":"#atom-eee-edition","children":[]},{"level":2,"title":"Kakoune","slug":"kakoune","link":"#kakoune","children":[]},{"level":2,"title":"Focus","slug":"focus","link":"#focus","children":[]},{"level":2,"title":"Kate","slug":"kate","link":"#kate","children":[]},{"level":2,"title":"Lem","slug":"lem","link":"#lem","children":[]},{"level":2,"title":"Lite","slug":"lite","link":"#lite","children":[]},{"level":2,"title":"Not even bad","slug":"not-even-bad","link":"#not-even-bad","children":[{"level":3,"title":"Lapce","slug":"lapce","link":"#lapce","children":[]}]},{"level":2,"title":"scite","slug":"scite","link":"#scite","children":[]},{"level":2,"title":"Pulsar/Atom","slug":"pulsar-atom","link":"#pulsar-atom","children":[]},{"level":2,"title":"Sublime text","slug":"sublime-text","link":"#sublime-text","children":[]},{"level":2,"title":"VSChrappium (also known as VSCodium)","slug":"vschrappium-also-known-as-vscodium","link":"#vschrappium-also-known-as-vscodium","children":[]},{"level":2,"title":"Acme","slug":"acme","link":"#acme","children":[]}],"git":{"updatedTime":1742751544000,"contributors":[{"name":"Aleksandr Petrosyan","username":"","email":"ap886@cantab.ac.uk","commits":8}],"changelog":[{"hash":"0d383b94a1e6bd6e15fdc04d85f9ceda3647fa4a","time":1742751544000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Migrate rants"},{"hash":"39c79fdeb75c795fb3d37c30fada4b5245d88492","time":1742750542000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Relocate rants"},{"hash":"bc5bda253540556643ed855b2cd5c7ee23c67889","time":1742747283000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Initial migration"},{"hash":"f18061824ab031f159c3b28304e34435de15aeed","time":1705441311000,"email":"a-p-petrosyan@yandex.ru","author":"Aleksandr Petrosyan","message":"[rants]: Emacs typos"},{"hash":"4899252636bc56ca89d63c1346e296beb352f97a","time":1705439910000,"email":"a-p-petrosyan@yandex.ru","author":"Aleksandr Petrosyan","message":"[rant]: <code v-pre>emacs</code> fix typo"},{"hash":"fafdbcb3d0b9086e2a27a4aeec0f0be7126fa69e","time":1705323266000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[emacs]: Added discussion of <code v-pre>not-even-wrong</code> editors"},{"hash":"68f2f79e2a5c44f6fbe2b19ccb083916cfa82560","time":1705253056000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[emacs]: Expand article"},{"hash":"c9be3c1c66782052fc8b96a691a870ab49b627ed","time":1704744219000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[feature]: Functional blog and sidebar"}]},"filePathRelative":"posts/rants/emacs.md","excerpt":"\\n<p>This is a blog post dedicated to my, and many other people's favourite text editor. In-keeping with the theme of this section, I shall mainly focus on the misunderstood nature of the editor, and my personal connection to it. Most of it is going to be in the negative light, so it slightly edges out being posted in the Software section.</p>"}`);export{l as comp,d as data};
