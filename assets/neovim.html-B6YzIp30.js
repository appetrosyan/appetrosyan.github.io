import{_ as t,c as o,a,o as i}from"./app-DUCnD5ZL.js";const n={};function s(d,e){return i(),o("div",null,e[0]||(e[0]=[a(`<h1 id="the-neovim-challenge-one-month-later" tabindex="-1"><a class="header-anchor" href="#the-neovim-challenge-one-month-later"><span>The Neovim challenge, one month later</span></a></h1><p>This is quite an interesting experience.</p><p>I will not say that I am wholly disappointed, but that it is sad. I&#39;ve been a <code>vi</code> user for the better part of my teens, and I&#39;ve only picked up Emacs around ten years ago, when I was 19. So this challenge was less of a dive into foreign waters, and more of a return to my own roots. And it is interesting to see your grandparents do some renovations, to see signs of prosperity in some areas, but to also notice that they are struggling. Not financially, but in that they&#39;ve lost track of what made them who they are.</p><p>My usage of Neovim was an interesting time and I fully intend to continue using it to the end of the month, perhaps a bit more into the next one. There is a lot of fruitful constructive reflection that took place and answered some of my questions about the direction of Emacs. While it is still possible that I might change my mind, to me at this stage, a return to the old lisp machine is inevitable. Neovim cannot replace it, even though for a time it looked like it could. And in principle, having known precisely what&#39;s missing, I&#39;d be able to build up the missing functionality, if it ever comes to that.</p><p>But the experience was not wholly untarnished, and like seeing signs of demention in one&#39;s grandparents, noticing these signs in NeoVim were a soul-shattering experience. It may be nothing. It may never become a problem. Or it may spell the end of a long tradition, which I would very much like to avoid.</p><h2 id="ed-and-the-predecessors" tabindex="-1"><a class="header-anchor" href="#ed-and-the-predecessors"><span>Ed and the predecessors</span></a></h2><p>Key to understanding this family of editors, the so-called <code>vi</code>-family, is their heritage.</p><p>Unix had a standard text editor, it was, as you might guess immediately called <code>ed</code> (but pronounced eeh-dee).</p><p>Ed is a command-driven interface. You don&#39;t have keys doing things, you have an editing instruction set with commands shortened to single symbols.</p><p>Using Ed exclusively for one&#39;s programming is an enlightening experience, as it imposes many of the important aspects of programming discipline, that one might not be able to pick up on. The size of files begins to matter, the pagers become important, line numbers become things that you worry about outside the error messages, and source files become things that one is able to memorise. While <code>ed</code>&#39;s design is often described as minimal, it is anything but. The whole intention behind <code>ed</code> is that it is an interface that one can program externally, and no editor to this day, outside of those that descend from it, seems to grasp the idiom of this being an editing language interpreter.</p><p>But this does not preclude the usage of <code>vi</code>. At some point, the loop of writing changes and printing the file became so prevalent, and computer resources have improved to such a degree that it became possible to do real-time visual text editing, (IKR, this is such a big leap forward, that we can&#39;t even imagine a computer that would be too slow to do that). This evoked the need to create a visual editor, such as <code>ex</code>&#39;s visual mode, which was invoked very simply with <code>argv[0] == &#39;vi&#39;</code>. The reason why <code>vi</code> was so popular at the time is the exact same reason why <code>emacs</code> was popular on lisp machines. It was visual. You could see your changes immediately, and much like the arcade machines, it was fun. I&#39;m writing this in <code>neovide</code>, which has a funny effect for when the cursor moves right after a character had been typed, and I admit it is supremely fun. Now imagine that <code>ex</code> is the only way to get that.</p><p>Now, naturally, <code>vi</code> is extremely good, and everyone in the Unix world was using it. But it was somewhat deficient in some areas. So the late great Bram Molenaar improved <code>vi</code> by adding on man-made horrors beyond one&#39;s imagination. Needless to say I did not care for <code>vim</code>. Partly, because why fix what isn&#39;t broken. Secondly, because <code>vi</code> was a ubiquitous, and <code>vim</code> was not. Thirdly, because having a configuration language, that is vimscript seemed antithetical to the ethos of both Unix and <code>vi</code>. <code>ed</code> defined an editing instruction set. Instruction sets are not extensible, and what in Emacs would be solved by an abstract function in <code>vi</code> would be solved by a concrete skill. Thus being able to remap things but making it non-standard seemed like a step backward.</p><p>But in all fairness there was a time, when <code>gvim</code> was my go-to editor, becuase it allowed me to copy and paste text from the exercises, and write the rest of the code that way. I also tinkered a little with the keybindings, and must admit that modal editing with the ability to remap keys seemed like a good idea. But regardless if I were asked &quot;what tool do you use&quot;, the answer would have been <code>vi</code>. Not <code>vim</code>, but plain <code>vi</code>, because the vast majority of the work that I was doing was pure, unaltered <code>vi</code>.</p><p>But <code>vim</code> had mass appeal. And soon became a staple. It was, for lack of a better term, the right tool for many tasks, including ones that were ordinarily not suitable for a plain text editor: IDEs for Java seemed to be a necessity, because one would not be able to produce code sufficiently quickly, given the verbose and tooling-dependent nature of the language. <code>vim</code> had plugins which would allow it to handle some of the basic refactoring functionality. And in some areas, <code>vimscript</code> allowed one to work around a problem ad-hoc, without invoking a keyboard macro.</p><p>Plus, <code>vim</code>, though extensible and willing to meet editors half-way, was still skill dependent. You were meant to learn how to use the <code>vim</code> motions and you were meant to get rid of the nasty habits, such as not using <code>di{</code> to delete blocks.</p><p>But the issues started to crop up over the years. While vimscript was meant to be a reliable DSL for configuring <code>vim</code>, it was ostensibly maintained by one person. To a point at which most people, including @ThePrimagean, decided never to learn it. <code>vim</code> occupied a niche, but that niche was very quickly overshadowed by <code>neovim</code>.</p><p>This project was where I was already completely committed to Emacs, and also stopped distro-hopping, so I saw a situation in which I would have to edit text from a TTY only in one context: over SSH, which thanks to a nifty built-in of Emacs, called TRAMP, offered a much better user experience than Vim ever could. As such, <code>neovim</code> was something I was not aware of for the longest time.</p><p>Still, I saw the effects of that project. It added asynchronous processing, it added a general purpose programming language that people would have been likely to program in, and not just for show. It had compatibility with graphical front-ends which were radically different from <code>gvim</code>, and offered much better interaction, and at this point, this is the go-to choice for most people who want to get into <code>vim</code>. I was not invested one way or the other, getting <code>emacs-native-comp</code> mainlined was more of a priority for me and around 20 other people. This is also when a similar project cropped up: <code>emacs-ng</code>, is a direct parallel to <code>neovim</code>. The reason why <code>neovim</code> took off and <code>emacs-ng</code> is now languishing in a limbo, is that people hate JavaScript and there was a concerted effort to fix Emacs lisp, while with VimScript, the general opinion is that it is broken beyond repair, and now with Bram Molenaar passing away, likely will remain that way indefinitely.</p><p>So <code>neovim</code> isn&#39;t necessarily better than <code>vim</code>, or <code>vi</code> or <code>ed</code>. They are occupying different niches: <code>ed</code> handles file editing in a command-driven format, and is often better than using a bunch of <code>sed</code> calls. The <code>vi</code>-sual editor, is a standard tool that can be used to quickly edit a file when one&#39;s graphical system is unavailable. <code>vim</code> is an extensible editor based on <code>vi</code>. <code>neovim</code> is a programming environment, or a code editor. They all exist in parallel, they are all extremely useful and they <strong>all</strong> require different skills, even though some of your muscle memory shall carry over, some of it will not, and it will annoy you.</p><p>I would recommend that you avoid falling into the trap of thinking that because they are supersets of each other, to think that using a smaller editor is devoid of value. As I mentioned, getting acquainted with the editing instruction set is supremely important. Often what is taken away is just as important as what is being added.</p><h2 id="why-neovim-in-2024" tabindex="-1"><a class="header-anchor" href="#why-neovim-in-2024"><span>Why NeoVim in 2024</span></a></h2><p>The complete list is very simple:</p><ul><li>Modal editing</li><li>Good performance</li><li>Extensible in Lua</li><li>Package ecosystem</li></ul><p>I will not preface this with bullshit along the lines of &quot;but there are other items in the list that are of course true&quot;. No. This is the complete list. Every other reason can be traced back to these principles of construction, but more often than not, they are not valid.</p><p>So let&#39;s go over these one by one, to expand a little and talk about the strengths.</p><h3 id="modal-editing" tabindex="-1"><a class="header-anchor" href="#modal-editing"><span>Modal editing</span></a></h3><p>Simply put, it is a way of skewing the skill curve such that earlier users have a harder time, but experienced users have an easier time.</p><p>The benefit that modal editing offers cannot be overstated. The supposed ergonomic benefits that <code>neovim</code> has over e.g. <code>emacs</code> can all be traced back to one&#39;s choice to be modal first, and the other to be discoverable first. The bet on the former, in my humble opinion, is better; one does not stick to either one of the editors unless they want to build up the skills. Modal editing dangles a carrot, wherein one knows that once they master the instruction set, they&#39;d be able to do structural editing more efficiently. This demands that one&#39;s both hands be glued to the keyboard, and in the home row, so for a touch typist, this makes a lot of sense. Most operations pick up incredible mnemonics, <code>dd</code> is delete line, <code>d2w</code> is delete two words. Sure, <code>yank</code> and <code>put</code> may seem archaic, but one very quickly learns that those keys are easily reachable. Because the navigation is done via the same keys that the typing is done with, a quick typist can also be a quick navigator.</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>One of the earlier concerns I had when returning to the <code>vi</code>-family was that I would have to expend resources to ensure that I&#39;m in the correct mode, but there are two ways around this. One: visual feedback done right, especially with block cursor and beam cursor. Secondly, if one comes from the Emacs family, hitting escape and following that with some motions is in no way a foreign concept. Starting any command with <code>Escape</code> and finishing with <code>i</code>, can give one a fairly solid illusion of living in a CUA-like editor.</p></div><p>Because the modality is an API that almost every package can respect, there is ample opportunity to bind various actions to easily reachable keys. The same effect can be emulated with Emacs&#39; native keybindings and minor mods, but I must admit, the emulation aspect needs to be done very carefully in order for it not to become a drag for every package that one has installed.</p><h3 id="good-performance" tabindex="-1"><a class="header-anchor" href="#good-performance"><span>Good performance</span></a></h3><p>This is an architectural consideration more than anything else.</p><p>Every decision comes with a trade-off. What is often confused with minimalism is actual judicious usage of &quot;it doesn&#39;t offer enough to justify the cost&quot;. And <code>neovim</code> is a master-class in this principle. It is far from minimal, it has modal chorded bindings, but the keys are responsive. It offers enough visual feedback but doesn&#39;t waste time making the cursor &quot;blink&quot;, because it is assumed that one is able to keep track of one block.</p><p>Being fast isn&#39;t a perceptual thing. It makes otherwise tedious tasks extremely satisfying. In <code>neovide</code> the front-end I chose, the ability to fly across buffers and to not pause led me to do more things. Combine that with some training via e.g. VimGolf, you get what is ostensibly a productivity boost. There&#39;s less resistance, there&#39;s more fun, and you end up doing more. At least in theory, but we&#39;ll get to that. Having fun while learning (and the cursor moving blazingly fast with a smooth animation is exactly that, fun) is the key to effective learning. You might not forget the things as quickly.</p><p>Working with <code>neovide</code>, having beautifully rendered objects and a somewhat different UI, that still offers a degree of familiarity, and is visually appealing is key to why surmounting the skill issues in the early days of using <code>vim</code> is oftentimes easier than surmounting smaller challenges in Emacs. There is some tentative evidence to support that speed of feedback is beneficial to learning when gaming, and I see some of the effects already.</p><p>But we must be careful to recognise that this is an archtiectural decision, that imposes its own limitations. It is not a pure benefit, but rather a trade-off with many positives and negatives that can be mitigated.</p><h3 id="extensible-in-lua" tabindex="-1"><a class="header-anchor" href="#extensible-in-lua"><span>Extensible in Lua</span></a></h3><p>This is perhaps one the least obvious aspects of <code>neovim</code>. But it is also the sole purpose, why <code>neovim</code> is even a contender for replacing Emacs for me. Lua is a general purpose programming language that has minimal bullshit. This is a loaded term, so I should probably elaborate.</p><p>Lua is a case study in an embeddable language done right. It has been perhaps the biggest and most interesting additions to the <code>vi</code> family since becoming visual, because Lua, unlike VimScript has an existence outside of the editor, allowing a cross-pollination of ideas and packages and code. Sadly this advantage does not extend to stronger networking, which made it problematic to integrate with LSP, at least initially, but the fact of the matter is, that Lua was the right choice.</p><p>Most code that is written in my <code>init.lua</code> is fairly readable. Lua is a curly-braced language, and as someone who does Rust and C++ for a living, the logic of Lua is the least far removed out of all of the major editor configuration languages. Yes it has idiosyncrasies, and sometimes they are annoying. But it is a far cry from Python or JavaScript.</p><p>This lead to something that I did not anticipate when I was going to dive head-first into <code>neovim</code>. When I started with Emacs, I needed a long time to grasp the basics. <code>setq</code> is very radically different from <code>var := val</code> that most other languages use. This approach is more powerful but learning Emacs has a lower skill floor compared to learning <code>vi</code>. At the same time learning Emacs lisp has perhaps the highest barrier of entry. But, believe it or not, it is also possible to configure neovim in Lisp! This means nothing, because if either part of the editor is <strong>not</strong> written in Lisp, most you gain is an esoteric syntax for namespaces.</p><h3 id="package-ecosystem" tabindex="-1"><a class="header-anchor" href="#package-ecosystem"><span>Package ecosystem</span></a></h3><p>This is perhaps the most surprising aspect of working with <code>neovim</code>. I did not expect it to have this many packages. It is still nothing in comparison to Emacs, but the roster is much richer than I anticipated.</p><p>The packages are in my opinion the crown jewel of <code>neovim</code> despite the particular execution of packages being perhaps one its weakest points.</p><p>I have not much good to say beyond that they exist, and they&#39;re not nearly as bad as I&#39;d expected them to be.</p><h2 id="why-emacs-is-still-better-in-my-eyes" tabindex="-1"><a class="header-anchor" href="#why-emacs-is-still-better-in-my-eyes"><span>Why Emacs is still better in my eyes</span></a></h2><p>At this point I must say that the original conclusion is a much more philosophical than technological discrepancy between the editors than I had originally anticipated.</p><p>The two editors are much more similar than they are different now, and I could equally replicate almost all of my workflow in either counterpart. The Org mode has decent support in <code>neovim</code>. There is an almost carbon copy of <code>magit</code> called <code>neogit</code> and most of the muscle memory that I had developed within Emacs can be translated to keybindings in <code>neovim</code>&#39;s insert mode, plus having the visual and normal modes. And as anyone who&#39;s ever used Emacs will attest to, <code>neovim</code> is significantly faster than Emacs, with all of the advantages that I&#39;ve been yapping about in the previous section.</p><p>So why in the world would I not just abandon Emacs and go with Neovim for the foreseeable future?</p><p>I will unfortunately have to state that modal editing has most of its power in cases where you are dealing with a curly braced language. I&#39;m afraid the proportion of situations where that takes place is becoming increasingly scarce. Given that I&#39;m left handed, and most navigation in Emacs can be effectively accomplished with chorded keybinds of the left hand, I&#39;m afraid I don&#39;t find the navigation to be significantly better in vim, and in fact, to be substantially worse. You could shout that it is a skill issue. Indeed it is! You have forgotten that I have been using vim motions for the better part of my earliest life and had to learn Emacs when I was &quot;already a man&quot; (TODO: Insert The dark knight rises meme here). It is your reading skills that are the problem. I have used both extensively and I will say that Emacs&#39; motion with tweaks is vastly superior to <code>vim</code>, particularly when editing prose.</p><p>In Emacs all I need to do is to toggle the <code>text-mode-auto-fill</code> and not worry about line breaks and line filling. I have olivetti mode, I have proportional fonts, and I can remove the markup markers, thus resuling in a WYSIWYG, with all of the other supposed benefits of plain-text. While initially I applauded the fact that <code>vim</code> has decided to keep the graphical clipboard separate from the <code>kill-ring</code>, I have found that this still implies that one has to use the concept of not cut-instead-of-delete to a far greater extent than in Emacs. The paradigms are not qualitatively different, they&#39;re just different and on the rare occasion that I need to paste code from a browser, I do so via the right-click menu of <code>neovide</code>, rather than a keybinding, because said keybindings don&#39;t seem to work and I have no way of disambiguating.</p><p>Neovim has a bunch more annoying less-than-efficiencies that seem to be an easy fix, but are usually not. Things like auto-complete which I fully expected to work out of the box, and to work better than e.g. <code>company</code> (to be fair, <code>company</code> is the worst package in my config at the moment), but that low-low bar seems insurmountable for <code>coq</code>, <code>complete</code> and a few others.</p><p>Lack of <code>dabbrev</code> is a significant drag on my productivity. I will say this much. Emacs&#39; <code>dabbrev</code> is better than it has any right to be. Any other form of &quot;intellisense&quot; is a significant downgrade. Emacs&#39; <code>dabbrev</code> tends to help my typing a whole lot more than one can imagine. Right now while typing up this passage, I find myself reaching for both <code>abbrev</code> for things like <code>.e.g.</code>, and <code>dabbrev</code> in my code and prose. These two major modes combined with the excellent templating libraries that already come built-in are why I think that Emacs still has undiscovered sub-surfac gems that nobody really sings the praises of enough.</p><p>A lot of things that I would consider important enough to work out of the box, seem lacking in <code>vim</code>. Emacs comes with <code>eglot</code> and <code>use-package</code> and many many other things just built-in. If I need to add a package to Emacs, all I need to do is to add</p><div class="language-lisp line-numbers-mode" data-highlighter="prismjs" data-ext="lisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> thing<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>at the end of my config file. This seems like not a lot, but this is a difference between <code>apt-get install thing</code> and adding <code>thing</code> to your <code>/etc/system.nix</code>. The difference is night and day, for someone with appreciation for such things. Want an example? Well, for one, <code>use-package</code> being a built-in means that you can in principle not have to start your <code>init.el</code> with anything other than that. Sure, if you want to bootstrap your system, you probably want to add things like <code>package-initialize</code> to the file, but you also need to do that song and dance for every other package manager.</p><div class="hint-container info"><p class="hint-container-title">UPDATE</p><p>apparently not anymore, and for package managers like <code>elpaca</code> you kinda have to disable init of the regulat package system</p></div><p>Incidentally, there&#39;s balkanisation of package managers on <code>vim</code>. There&#39;s multiple, some of them are no longer maintained, and while in most situations the syntax for adding new packages in one&#39;s config file is simple, it&#39;s a matter of time before the complexities rear their ugly head. This is not a solved problem with Emacs, as there are <code>elpaca</code> and <code>straight</code> but they have chosen (a sign of great wisdom in my opinion), to not indulge in frivolous differences in API, but rather to work as plugins for <code>use-package</code>. As such, the instructions on all packages can appear as if one were only using <code>use-package</code> and not care about the underlying pacakge manager. Even though the syntax is remarkably similar across <code>lazy.nvim</code> and <code>packer.nvim</code> these two are distinct. As such, the existence of either is nothing more than a manifestation of the tower of babel.</p><p>And this is important. There are more than just cosmetic differences between <code>use-package</code> and the way that neovim chooses to install their packages. The fact that a <code>use-package</code> form can be a self-contained declaration that haas no traces anywhere else in the config file. This means that removing a package is the same as deleting the declaration. Garbage collecting it, is equivalent to deleting the <code>elpa</code> sub-folder. With <code>neovim</code> it is not so.</p><p>But there are grander compromises that need to be talked about.</p><h3 id="modal-editing-is-not-that-difficult" tabindex="-1"><a class="header-anchor" href="#modal-editing-is-not-that-difficult"><span>Modal editing is not that difficult</span></a></h3><p>I know that I had been praising modal editing so far. And I will not renege on my praise, but rather mention that given how Emacs is organised, it is perfectly feasible to create a <code>vi</code>-like modal editing environment if you are a beginner in writing Emacs lisp. That is not to say that you would be meeting the levels of <code>evil</code> or <code>meow</code>, those would require a considerable amount of elbow grease, but there are no principal reasons why modal editing is to be considered a <code>vim</code>-only feature. While I did so initially, I no longer use modal editing in Emacs all the time. When I do, I prefer quasi-modal (pardon the pun) editing in the style of <code>cdlatex</code> where a symbol can invoke a collection of context-sensitive operations, rather than overloading the existing modifiers.</p><p>The ergonomic argument in favour of modal editing is overblown in my opinion, because as anyone whom has ever attempted to learn a new keyboard layout will attest to, the symbolic bindings in <code>vim</code>, make sure that nothing save mnemonics remains ergonomic in the long run. Vim requires the same level of configuration as Emacs would, if one wanted to use an esoteric layout or god forbid stenograpic keyboards.</p><p>Even so, there&#39;s a few more aspects to the other side of ergonomics. While Emacs is not exactly similar to <code>vim</code> out of the box in terms of ergonomy, it can compete with it fairly efficiently if you are willing to adjust your keyboard. There&#39;s a phenomenon known as the &quot;Emacs pinky&quot;, a nod to the fact that in Emacs one is often using <code>Ctrl</code>-based shortcuts to do basic operations. This is somewhat true but not exactly a problem. You see the old keyboards have had their Control key, where the bestige that should have died now lives, the &quot;Caps Lock&quot;. Every window manager I&#39;ve used on Linux, some windows machines and Mac OS for that matter allow one to remap a useful key to a location where a useless key tended to reside. It is a bit of an issue, but I think that if you care about ergnomics, and you base your choice of life investment, you should keep in mind that rebinding a key does not compensate for the subject of this section.</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>And in all fairness, modern day keyboards are not particularly good. We often have an <code>fn</code> key which is useless, and cannot be remapped. Some ChromeOS devices decided they did not need a third modifier, and rolled back to the pre-model-M layout of only Ctrl and Alt, while neglecting to remove the key that I don&#39;t think many people consciously use anymore.</p></div><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>The only real complaint I can levy on Emacs, is its staunch refusal to adhere to modern sensibilities. There are certain key combinations that cannot be bound to: namely <code>C-i</code>, <code>C-m</code>, <code>S-TAB</code>, <code>S-&lt;space&gt;</code> and a few others. I understand why there is resistance to removing these bindings, there are still people whose workflow depends on interpreting a sharp temperature rise as <code>Ctrl</code>. There is a way to toggle CUA mode that maps <code>C-c</code>, <code>C-z</code> and <code>C-v</code> to their &quot;regular&quot; meanings from the IBM CUA standard, I would like there to be a &quot;toggle modern keyboard mode&quot; option that can be opt-in that disables those remappings and does not retranslate any of the keystrokes to anything archaic. I understand that binding <code>C-i</code> to indent is sensible and convenient, I would just like to be able to then bind <code>Tab</code> to something else.</p></div><p>What I found is that the <code>kakoune</code> team of which I was skeptical at first, definitely has a refinement of the modal editing paradigm, but the solution, was actually convergent evolution with what Emacs already does.</p><p>The instruction set of <code>ed</code> is very direct. You give an operator and two operands and this carried over through to <code>vim</code>. In most situations what is accomplished by the notion of a <code>vim</code> motion, can also be accomplished by using the so-called <code>visual</code> mode, i.e. selection, where you have placed a cursor in one place, and it stays static, while regular motion commands transfer the cursor in a way in which the selection is extended from the original point. Emacs has a similar mode, called a transient mark mode, which had been enabled by default. This means that all one needs to do to replicate the behaviour of <code>vim</code> is to select the region on which one needs to operate first, and do the manipulations second.</p><p>Consider then what one needs to do to delete the contents of a curly-braced function. In <code>neovim</code>? Easy, just <code>da{</code>. Except if your cursor is inside an <code>if</code>-statment you would need to walk away from that scope. One would need to place the cursor in a specific spot. You might realise that this is the case, when you&#39;ve already invoked the command and it didn&#39;t do what you wanted. Kakoune addresses this latter issue by having visual feedback on what the region acted upon must be. In Emacs, this is far simpler. Delimiters define so-called <code>s-expressions</code>, so if I&#39;m at the opening curly-brace, killing the body of a function is accomplished with <code>C-M-&lt;space&gt; DEL</code>.</p><p>You might counter by saying that this is both more keystrokes, less mnemonic and it depends on the cursor position. It is worse. But I will say the two approaches are on equal footing for one simple reason.</p><ul><li>if we count modifier presses as keystrokes, then <code>{</code> counts as two, bringing us to four in total. Equally if we count is as one, then <code>C-M-SPC</code> should count as one, as it is both easy to press, and used frequently in Emacs.</li><li>Mnemonicity is a matter of perspective and model. <code>C-SPC</code> is a way to mark objects in Emacs. <code>C-M-SPC</code> is a way to mark many objects that are delimited. They are related, and thus it is not difficult to remember. Plus, <code>SPC</code>-containing keybinds have a special place and must be handled specially. In <code>vim</code> one would first need to know why one has to delete &quot;around&quot; and not &quot;inside&quot; the region.</li><li>As I&#39;ve alluded to earlier, the same is true of <code>vim</code>. With Emacs, though one does not have to make a decision to move the cursor to the initial position of the function definition, because one knows how to select the function body. I agree it is not perfect, but without pacakges, one does not exactly have a good solution in either case.</li></ul><p>Technically there&#39;s a way around this using <code>tree-sitter</code> integration. These are tempermental and while writing a <code>tree-sitter</code> grammar is the preferred solution for both editors, using a regular expression-based major mode in Emacs can approximate a function definition better than can a <code>vim</code> motion. There are few places where one can learn about definition of textobjects, while almost all of the major modes are written in Emacs lisp.</p><p>With pacakges, the situation is radically different. In Emacs I know of <code>smartparens</code> that would allow one to do that in a single command, and if one anticipates that killing and yanking function bodies, as opposed to entire paragraphs is something that they&#39;ll do often, they can adjust them.</p><p>And this is key!</p><p>Modal editing is neither exclusive to <code>vim</code>, nor is it fundamentally better than non-modal editing. Even so, it is then reasonable to state that something like <code>kakoune</code> is a far superior editor, because its notion of text object allows non-destructive feedback before an operation is performed, not <code>vim</code> and not even <code>neovim</code> can claim the same.</p><p>I can borrow concepts that I like being modal and transfer them to Emacs with <code>general</code> but be far more productive in the <code>insert</code>-ion mode because Emacs exposes its full API in that mode, while <code>vi</code> does not.</p><h3 id="good-performance-is-a-work-in-progress" tabindex="-1"><a class="header-anchor" href="#good-performance-is-a-work-in-progress"><span>Good performance is a work in progress</span></a></h3><p>This is perhaps the one place where I&#39;d say that good performance is good. Emacs is noticeably less performant as a program, owing to the blocking single-threaded nature of the Emacs lisp interpreter that it is built around.</p><p>Emacs is less responsive, but not slower.</p><p>But the truth is, that despite this it is in no way slower. It is just that one is encouraged to think more specifically about the problems that one encounters while editing, and how to solve them. A common solution to most vimgolf problems in Emacs, is to record a macro. Indeed, because a macro is a function of repeated application of a group of operations, and breaking down editing into operational groups is perhaps the impetus behind both editors.</p><p>The difference is that <code>vi</code> is more like assembly. It provides editing-Turing-completeness, but most operations are combinations of the primitives. Both <code>neovim</code> and Emacs break down objects into functions, which can themselves be re-usable. In <code>neovim</code> I would need to provide a notion of a textobject, with extents and positions a more declarative, but involved approach. With Emacs, to define a notion of a new text object, all one needs to do is to define how to move to the end and to the beginning of the extent. If the move operations only work correctly in some circumstances, those become the context for the concept itself. Specifically, citing from the example of the previous seciton, to mark a symbolic expression one assumes that the next character is the opening delimiter, and seeks until it encounters a matching closing delimiter. It is trivial to write the function differently to include the group of arguments, but not the whole of the signature or to move the beginning position. One can extend and sophisticate the behaviour to a great extent. With <code>neovim</code> I will assume that the same mechanism works, because all one needs to do is exactly the same.</p><p>In principle both operations are going to be linear in the extent of the text between the delimiters. Neovim has a slight edge because it can concurrently scan multiple lines if that is the case, but in practical terms both of those are extremely quick. Lua interprets to a fast JIT, while Emacs Lisp is often plain natively compiled.</p><p>The only difference in the speed of operation between <code>neovim</code> and Emacs, is purely perceptual. This is something that had been brought up countless times, and a significant pain point in the modern day Emacs commmunity. Being slow comes down to a psychological effect that I can choose to ignore until it is fixed.</p><p>Potentially, though it may be possible to make it go away by creating a front-end that connects to an Emacs server as a backend until a pure solution is found.</p><p>I will conceed that I will miss <code>neovide</code>&#39;s lightning fast reponse and ability to do complex tasks very quickly. Emacs will do the same, but look worse while doing so. That is pretty much the extent of it.</p><h3 id="extensible-in-lua-but-lua-is-not-as-powerful-as-lisp" tabindex="-1"><a class="header-anchor" href="#extensible-in-lua-but-lua-is-not-as-powerful-as-lisp"><span>Extensible in Lua, but Lua is not as powerful as Lisp</span></a></h3><p>This is somewhat controversial. But I will say that the way that <code>neovim</code> requires one to work around Lua is sub-optimal.</p><p>Emacs lisp offers immense power that Lua can only approximate and only for the general population. Something like <code>use-package</code> would be incredibly difficult to create in Lua, if not impossible. It would rely heavily on tables and would in general be a form of a DSL. The difference is that in the lisp world, a DSL is still a lisp, but with syntax extensions. Within the curly-braced family that is not so and Java is qualitatively different from Rust, which is qualitatively different from C++.</p><p>There are also issues stemming from the fact that <code>neovim</code> is a dual citizen of VimScript, and Lua for extensions and some things are implemented as C-functions. It is a problem that is pertinent to Emacs as well, but thanks to its incredible documentation viewer less problematic. Emacs has many packages implemented in the Common-lisp sub-dialect, and everything has to speak Emacs lisp in the end, but that is far from a problem.</p><p>Perhaps one thing I find extremely annoying is significant comments, that are not highlighted as significant and not handled as they should: via macro. But in all fairness the fact that Emacs complains about punctuation and many many other things when you go off and write your own elisp functions leads one to be able to write better programs. Lua does not encourage such practices. This shows in some areas.</p><p>Finally Emacs lisp has one feature that Lua will never have, and that is the ability to do incremental evaluation.</p><p>If I wanted to install a new package, all I would need to do is to write the <code>(use-package thing)</code> and hit <code>C-x C-e</code> on it. This will evaluate that form, and only that form. The result of which is a quick understanding of what functions can do, and an extremely rapid prototyping cycle. With <code>neovide</code> in order for <code>lazy</code> to <strong>actually</strong> download the package that I want, I need to close and reopen <code>neovide</code>. It is fast, much faster than Emacs, but at the same time it is unnecessary.</p><h3 id="package-ecosystem-is-worse" tabindex="-1"><a class="header-anchor" href="#package-ecosystem-is-worse"><span>Package ecosystem is worse</span></a></h3><p>Emacs offers a smaller number of much better polished packages that are often, also significantly shorter than their <code>neovim</code> counterparts. They rarely if ever have walls of text as Readmes, and often don&#39;t need to provide anything beyond the regular docstrings. The amount of effort and opportunities to make a radical mistake in an Emacs package is orders of magnitude lower than that in Lua for <code>neovim</code>.</p><p>And it shows.</p><p>I found that while <code>neovim</code> has a large number of packages, it has far less impressive stuff, and in some areas things that I would hardly qualify as useful, and errs more on the side of providing the functionality and hoping that the functionality will find a use, rather than purposeful exploration. Additionally, most packages for Neovim are written quite recently. This is a problem, because it indicates a lack of longevity in these packages and an API instability. With Emacs it is often the case that packages go stale, but it is often the case that pacakges that hadn&#39;t been updated since the 2000&#39;s are still quite functional and didn&#39;t need to be updated to work. Emacs lisp hasn&#39;t changed much even though the host application did.</p><p>I was infuriated to find that the perception that <code>vim</code> is targetted for packages way more than any other editor that doesn&#39;t live inside a browser, was based on a combination of stale &quot;awesome&quot; lists, marketing hype, and inability to differentiate serious projects from those that think that providing VSChrap support is tantamount to providing IDE tooling.</p><p>The reason why that might be the case comes down to the following three things that didn&#39;t seem obvious to me until I&#39;ve seen the state of Neovim packages:</p><ul><li>Emacs is very adverse to non-free software. This extends to the default package archives. It is also the main reason why up until very recently it was not possible to load packages written in native executable formats.</li><li>Emacs lisp is not a general programming language. Very few people who &quot;know how to code&quot; can pick up Lisp on the go. It will require one to reframe their mind and to work differently.</li><li>Emacs does not advertise its forward-looking features well. I once had to prove to a maintainer of an &quot;awesome&quot; list that Emacs was not a terminal text editor. This is something being worked upon, I believe that a rebranding would be useful, but it will not shift mindshare much.</li><li>The Emacs community consists of people who will not enter a flame war and prove that the editor is good. So anyone who gets most of their information from reddit, or some other &quot;loudest opinion is correct&quot; platform, will get the impression that Emacs is worse than it actually is.</li><li>Emacs advocates focus on the wrong things. This is perhaps most evident when asking if Emacs has &quot;killer apps&quot;. Most would cite <code>org</code> or <code>magit</code> and <strong>maybe</strong> mention <code>dired</code> or <code>tetris</code>. Those are packages that 1) I can easily live without, 2) I don&#39;t think are radically better than other packages doing the same thing, 3) even if present in other editors (and Neovim has also <code>neorg</code> which is a dumbed-down version of <code>org</code> touted as an improvement), they do not make those editors remotely comparable.</li></ul><p>Vim has a loud community of people. Despite the fact that it is trivial to replicate <code>vim</code> inside Emacs, @ThePrimagean would insist on making jokes about skill issues, and how <code>vim</code> is better. Indeed, if all you do and all you&#39;ll ever do, is edit C-like curly braced code, <code>vim</code> has a certain appeal, and a few advantages. I&#39;ve conceded those when I started this article. <strong>AND I REALLY SHOULDN&#39;T HAVE</strong>.</p><h2 id="takeways" tabindex="-1"><a class="header-anchor" href="#takeways"><span>Takeways</span></a></h2><p>I fully left the door open to switching sides and using this new tool for a long time, until mine reaches a level of maturity. I don&#39;t think that&#39;s correct.</p><p>What I think I should do instead, is to take this experience and refine what is missing. Particularly, I have actionable points, that only exist because I have had a bout of using <code>neovide</code>.</p><p>Emacs needs its own widget toolset. This means that I would need to hack around the <code>redisplay</code> function and allow for it to be extended.</p><p>We don&#39;t have enough tutorials in Emacs, and an over-abundance of 1337 haxxors that shall concede no ground and never admit any wrong. I don&#39;t particularly have a problem with how <code>vim</code> works. It&#39;s not exactly what I&#39;d call efficient, but if Emacs died tomorrow, or stopped improving at a breakneck pace, I&#39;d use <code>vim</code>. I&#39;ve used it before, I can do so again. But I find it quite problematic that people don&#39;t exactly have a great deal of understanding. They think that <code>vim</code> is what it is not, and that Emacs isn&#39;t what it is: a fine text editor. This can be fixed by, shall we say, having a decent amount of documentation and &quot;street cred&quot;.</p><p>Thirdly, there&#39;s a good reason to try and create a more responsive UI for Emacs. The main mistake architecturally speaking is that the Emacs lisp interpreter is bundled with a horrendous mess of GTK. Emacs deserves its own toolkit. This is far from unfixable.</p><p>Indeed while it would be perhaps too cumbersome to try and decouple the code for the time being, I&#39;ll contend myself with writing a Neovide-like front end, and making it connect to an existing emacs daemon. This shouldn&#39;t be insurmountable, and in fact is probably easier than writing one&#39;s own text editor. It should also allow Emacs to slowly wean itself off of the GTK front-end. Here the slow release cycle of Emacs is a benefit, because I can target a stable API and ABI. All I&#39;d need to do is begin the hard part that can break only when there had been a large non-maintenance release. Finally, the code and the copyright is to be signed off to the GNU foundation. That way this work can be upstreamed, and Emacs can finally shake off the burden of being a text-only editor with <em>no form</em> and <em>all function</em>.</p><h2 id="useful-ideas" tabindex="-1"><a class="header-anchor" href="#useful-ideas"><span>Useful ideas</span></a></h2><p>Ergonomic keybinds. <code>hjkl</code> for navigation is perfect.</p><p>Editing functions exposed to the user and written by the user. The editor by itself doesn&#39;t come with any configurations.</p><p>Plugins are libraries.</p><p>Exiting to <code>normal</code> mode has action (cleans up whitespace).</p><p>instead of motions, define a highlighting method. Build it in, because any of the EasyMotion and others actually modify the buffer.</p><p>Modal navigation. Most people don&#39;t use the <code>]</code> and <code>}</code> when using Vim.</p><p>Transients are useful.</p><p>When writing the easymotion I could add ways of defining the motion to specific objects: <code>$</code> at the end, <code>w</code> at the end of the word, overlay it graphically.</p><p>Rely on the WM to provide tabbing and windows. Only open new ones, never tabs.</p>`,117)]))}const c=t(n,[["render",s],["__file","neovim.html.vue"]]),l=JSON.parse(`{"path":"/posts/rants/neovim.html","title":"The Neovim challenge, one month later","lang":"en-GB","frontmatter":{"date":"2024-02-17T00:00:00.000Z","category":["Work","Tooling"]},"headers":[{"level":2,"title":"Ed and the predecessors","slug":"ed-and-the-predecessors","link":"#ed-and-the-predecessors","children":[]},{"level":2,"title":"Why NeoVim in 2024","slug":"why-neovim-in-2024","link":"#why-neovim-in-2024","children":[{"level":3,"title":"Modal editing","slug":"modal-editing","link":"#modal-editing","children":[]},{"level":3,"title":"Good performance","slug":"good-performance","link":"#good-performance","children":[]},{"level":3,"title":"Extensible in Lua","slug":"extensible-in-lua","link":"#extensible-in-lua","children":[]},{"level":3,"title":"Package ecosystem","slug":"package-ecosystem","link":"#package-ecosystem","children":[]}]},{"level":2,"title":"Why Emacs is still better in my eyes","slug":"why-emacs-is-still-better-in-my-eyes","link":"#why-emacs-is-still-better-in-my-eyes","children":[{"level":3,"title":"Modal editing is not that difficult","slug":"modal-editing-is-not-that-difficult","link":"#modal-editing-is-not-that-difficult","children":[]},{"level":3,"title":"Good performance is a work in progress","slug":"good-performance-is-a-work-in-progress","link":"#good-performance-is-a-work-in-progress","children":[]},{"level":3,"title":"Extensible in Lua, but Lua is not as powerful as Lisp","slug":"extensible-in-lua-but-lua-is-not-as-powerful-as-lisp","link":"#extensible-in-lua-but-lua-is-not-as-powerful-as-lisp","children":[]},{"level":3,"title":"Package ecosystem is worse","slug":"package-ecosystem-is-worse","link":"#package-ecosystem-is-worse","children":[]}]},{"level":2,"title":"Takeways","slug":"takeways","link":"#takeways","children":[]},{"level":2,"title":"Useful ideas","slug":"useful-ideas","link":"#useful-ideas","children":[]}],"git":{"updatedTime":1742751544000,"contributors":[{"name":"Aleksandr Petrosyan","username":"","email":"ap886@cantab.ac.uk","commits":8}],"changelog":[{"hash":"0d383b94a1e6bd6e15fdc04d85f9ceda3647fa4a","time":1742751544000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Migrate rants"},{"hash":"39c79fdeb75c795fb3d37c30fada4b5245d88492","time":1742750542000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Relocate rants"},{"hash":"bc5bda253540556643ed855b2cd5c7ee23c67889","time":1742747283000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Initial migration"},{"hash":"0e45ff5a7a34012b3d12da0665a99ee261cd8603","time":1712600991000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[fix] formatting"},{"hash":"77c960e103ebb18ad7f3944702dd9b64e2d2992b","time":1712477198000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[rant]: <code v-pre>vim</code>"},{"hash":"9755eebc57c418e438344cab959b5148e13c0da3","time":1709791670000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[doc]: Add <code v-pre>supernest</code>"},{"hash":"d5afead67830a4c324dbe37d15c2d98f58aa8206","time":1708178966000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[rant]: neovim add conclusion"},{"hash":"6396e6f6034318cfc88231320834946c34642663","time":1708178492000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[rant]: Neovim"}]},"filePathRelative":"posts/rants/neovim.md","excerpt":"\\n<p>This is quite an interesting experience.</p>\\n<p>I will not say that I am wholly disappointed, but that it is sad. I've been a <code>vi</code> user for the better part of my teens, and I've only picked up Emacs around ten years ago, when I was 19. So this challenge was less of a dive into foreign waters, and more of a return to my own roots. And it is interesting to see your grandparents do some renovations, to see signs of prosperity in some areas, but to also notice that they are struggling. Not financially, but in that they've lost track of what made them who they are.</p>"}`);export{c as comp,l as data};
