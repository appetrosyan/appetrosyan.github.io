import{_ as t,c as o,a,o as i}from"./app-Cs446qsf.js";const n={};function s(r,e){return i(),o("div",null,e[0]||(e[0]=[a('<h1 id="language-servers-in-emacs" tabindex="-1"><a class="header-anchor" href="#language-servers-in-emacs"><span>Language servers in Emacs</span></a></h1><p>In this post I will try to summarise my experience with all things LSP (language server protocol). I will talk primarily about the two most important implementations of LSP for Emacs: <code>eglot</code> that is built into Emacs, and <code>lsp-mode</code> that seems to be much more feature complete.</p><p>I will delve into the pros and cons of both, explain why I use both as daily drivers and why I prefer to not have them be enabled by default for any mode, and what to do if you don&#39;t like the idea of LSP.</p><h2 id="language-server-protocol" tabindex="-1"><a class="header-anchor" href="#language-server-protocol"><span>Language Server Protocol</span></a></h2><p>The language server protocol is a protocol of communication between an editor of your choosing, and a language server, the actual program that handles the &quot;heavy lifting&quot; of parsing and language-specific manipulations, such as refactoring and renaming and a few other things that are specified as protocol extensions, such as expansion of macros running unit tests if they are defined in-line as in <em>e.g.</em> Java, and Rust.</p><p>It was first touted as a grand shift in paradigm. While I will not doubt its utility, hence the existence of this article altogether, I will say that I do not consider it to be as revolutionary an idea as Microsoft, the creator of this protocol would have you believe. It is a useful tool; it&#39;s not a must-have like many of the Emacs built-ins <em>e.g.</em> <code>dabbrev</code>, not a vast improvement to quality of life like <em>e.g.</em> <code>eldoc</code> or <code>corfu</code> or <code>jinx</code>, but nonetheless a tool I occasionally use.</p><p>So, how does it work? Because Visual Studio Code is an editor that is built largely on browser technology, the main mode of interaction is via a JSON remote-procedure-call architecture. This usually means that the server has JSON-encoded plain-text messages sent and received. While one could control the server manually with a tool like <code>curl</code>, Emacs&#39; <code>eglot</code> handles management of both starting and keeping the language server up to date. Because of the fact that JSON is a ubiquitous format with abundant tooling, extending the language server plugin is also not as difficult as it could have been otherwise. This usually means that the language server plugins, like <em>e.g.</em> <code>lsp-mode</code> and <code>eglot</code> get updates quickly.</p><p>What the language server allows you to do, is largely individually determined by the specific use case and the specific language server.</p><p>For example, Rust is a language that relies on tooling quite heavily, many things must adhere to strict rules, and code is verbose. Having <code>eglot</code> automatically enabled for Rust is useful.</p><p>(TODO) Figure, how Rust is used.</p><p>Python can benefit from LSP, largely by providing documentation, auto-completion, and refactoring. But it also benefits from a minimalist approach, which programmers naturally fall into if they do not have an active LSP.</p><p>Finally, languages like LaTeX, though they provide a language server, are of a drastically different kind and therefore benefit minimally if at all.</p><p>The quality of language servers also varies. Some &quot;production-ready&quot; servers do not have support for rudimentary refactoring operations such as renaming. The Rust language server: <code>rust-analyzer</code> consumes much memory, and is often in need of an expensive indexing operation at the beginning of its operation. It is controversial, but I have found that these language servers can occasionally produce invalid code. The nature of their operations, though, thankfully prevents those changes from being irreversible, as it is almost a requirement for them to have the files that they touch be open in your text editor.</p><h2 id="eglot-and-where-it-shines" tabindex="-1"><a class="header-anchor" href="#eglot-and-where-it-shines"><span>Eglot and where it shines</span></a></h2><p>I have done a small challenge, where aside from my colour theme, and a few visibility packages, such as (<code>color-identifiers-mode</code>), I had used unmodified Emacs for a period of no less than two months. Predictably this was much easier I had anticipated, because for every function that I accomplish with a package, there is at least one built-in that does the same, and largely better. The Emacs LSP support is one of those built-ins and by default requires minimal configuration on the Emacs side of things.</p><p>If you want to enable a language server to handle your buffer, all you need is to <code>M-x eglot</code>. Most fancy features can be enabled via <code>M-x customize</code>, but I rarely need anything more than type hints for Rust, and even then, sometimes they are more trouble than their worth in terms of readability.</p><p>Eglot is rather minimal package. By itself and without any modifications to the minibuffer: the small area where you interact with the editor, it offers an interface that is a tad outdated: one would have to cycle through their options one by one, without seeing if the one they want is listed, and unless the minibuffer is configured to accept fuzzy-finding the candidate, you are even more likely to have to just pick and choose from an invisible list. This is by no means an indictment of <code>eglot</code>, merely a signal of how it is meant to be used.</p><p>The Emacs polyGLOT package is specifically designed to fit into a complex ecosystem of packages. It does so, by providing a sane usage of the basic APIs, which makes it compatible with most if not all minibuffer enhancers: such as <code>vertico</code>, <code>helm</code> and to some extent the built-in <code>fido-mode</code>. The same is true of auto-completion; <code>eglot</code> expects you to have installed something like <code>company</code>, <code>corfu</code>, and maybe to have mastered the usage of <code>C-M-i</code>. You as the user are given the ultimate choice, but are expected to know your preferences.</p><p>The result is that <code>eglot</code> occasionally feels like it is not as feature complete, despite the amount of work that has been poured into it. Joao Tavora, the person behind <code>eglot</code> and a few other of my mainstay packages, is also reluctant to implement features and the package as a whole has received a modest amount of code contributions. This might seem like a scathing critique of <code>eglot</code>, but for anyone who has used Emacs for any length of time it would be a glowing endorsement.</p><p>It is true that the upstream <code>eglot</code> would not implement protocol extensions. It is also true that <code>eglot-x</code> does, and is mentioned in the README of <code>eglot</code>. It is true that <code>eglot</code> has not seen many code changes in over a year as of writing. Which usually means that there hadn&#39;t been frivolous code changes that add nothing, and make sure that you also have to do work repeatedly. It is also eminently true that some ideas such as allowing the LSP to handle the parsing of source code was not accepted. The upshot is that it is a feature that for Emacs would be supremely problematic for no apparent gain, given <code>tree-sitter</code> and the abundance of modes that support it.</p><h2 id="interlude-technological-challenges" tabindex="-1"><a class="header-anchor" href="#interlude-technological-challenges"><span>Interlude: technological challenges</span></a></h2><p>At this point you might be tempted to ask if there are any technological challenges associated to using any of the LSPs with Emacs. The unfortunate truth of the matter is that there are huge problems that are hard to fix, which are nonetheless something that causes only minor inconvenience to the user.</p><p>The main problem is that the lisp machine that is Emacs has a different programming paradigm to most modern programming languages. A lot of the time, you expect the state change to be the primary effect. <code>forward-word</code> doesn&#39;t return the location of the next word if called-non-interactively, it moves the point forward by one word. This complicates things as regards to how asynchronous programming is to be handled. The amount of state that you would have to carry over in order to ensure correct operation of your function in a separate process is huge.</p><p>On a similar note, one usually has to deal with a rather outdated simple garbage collector. Make no mistake, these are intentional architectural decisions which were made early on with the intention of creating a sane computational platform, and without being able to anticipate where the hardware was going. If we kept on doubling the clock frequency as we thought we would up until the late 2000s, none of these decisions would even be a blip on the radar. The GC being simple would be praised, as it would keep the Emacs program itself eminently reliable and free of memory errors. And being synchronous would be praised because it would prevent a whole class of bugs, that I&#39;m sure anyone who has done <code>async</code> Rust or <code>asyncio</code> in Python will attest to, are not fun to debug.</p><p>This is particularly important because of one thing: the LSP communication requires a lot of Emacs lisp to run. This produces much garbage that in turn needs to be collected. Unfortunately, setting the collection thresholds higher can only stave off the symptoms momentarily. This is something that used to be recommended, but also something which can result in your system being prone to lockups at the worst conceivable times, <em>e.g.</em> when writing code. Setting lower thresholds results in shorter delays but more frequent freezes, which given that almost every operation that involves LSP deals with a large amount of data being communicated both ways, one can&#39;t help but notice frequent hitching.</p><p>This is not normally a problem, but if I have a dramatic slowdown, disabling the LSP is the first thing that I do. It doesn&#39;t always help, and it isn&#39;t always LSP&#39;s fault, but one cannot help but feel a force of habit. Moreover, this is one of the main reasons why some (arguably) sensible features get left out of packages such as <code>eglot</code>. Recall that the language server specification actually allows the server to <a href="https://github.com/joaotavora/eglot/issues/615" target="_blank" rel="noopener noreferrer">handle syntax highlighting</a>. This is a rather sensible thing to do, if one assumes that processing JSON happens faster than parsing the file itself. The main problem is that in Emacs, due to the fact that you can&#39;t simply <code>eval</code> the result and produce a lot of memory allocations that need to be freed subsequently, <code>eglot</code> would slow the user down quite significantly.</p><p>Obviously these technological challenges are largely addressable. They hold back some developments for a time, but eventually most technological developments make it into Emacs.</p><h2 id="lsp-mode" tabindex="-1"><a class="header-anchor" href="#lsp-mode"><span>LSP-mode</span></a></h2><p>The <code>lsp-mode</code> is the package that with a few tweaks could have been the new built-in. It is a different and in my opinion much more complex approach to LSP. The upshot is that it replicates the look and feel of mainstream code editors such as the Jet-Brains family, the Electron code editors, sublime text and something to which <code>neovim</code> also gravitates.</p><p>Simply put, <code>lsp-mode</code> has abundant documentation, it is well regarded in developer circles, it offers a wider feature coverage, and often results in a more streamlined experience for the user. It is also, as of writing the only one-click route to code lenses and being able to run a unit test from the comfort of your text editor.</p><p>It comes with in-line diagnostics if you enable <code>lsp-ui</code>. It comes with debug adapter protocol, which is supremely useful in some areas. It comes with a wider coverage of protocol extensions, such as the ability to expand Rust macros without any further packages needing installation.</p><p>From a purely on-paper perspective, <code>lsp-mode</code> is a direct upgrade to <code>eglot</code>. For some that is true, but I find myself in the unenviable position of not liking it all that much.</p><p>My first point is that while <code>lsp-mode</code> <em>attempts</em> to bring Emacs to the standards of the modern editors, a lot of the design decisions in Emacs provide better alternatives with a higher skill ceiling. Specifically, I quite like that we do not have pervasive tabs and file-system trees. Emacs allows you to create those UI elements, but opts you out of them by default, because one does not need them. If I want to switch to a file that is already open in Emacs, I do <code>C-x b</code>, and that gives me indexed search. If I want to open another file, I use <code>C-x C-f</code>, which even with built-ins like <code>fido-mode</code> offers enough detail to be just as effective as a tree.</p><p>The same is true of diagnostics provided by the LSP, <code>eglot</code> sensibly assumes that you either have the built-in <code>flymake</code> that forces you to write <code>;;; init.el ends here</code> for every elisp file you created, or <code>flycheck</code> that for a time offered a better coverage of diagnostics without the language server protocol. By contrast, <code>lsp-mode</code> assumes that you would want some things to be handled hassle-free and don&#39;t like the built-ins; it will opt you into <code>company</code>, <code>yasnippet</code> (which is incidentally maintained by Joao) among a few others.</p><p>Much of my coding relies on <code>dabbrev</code>. A lot of the time, I can complete an entire identifier in one or two keystrokes and not have to worry about typos. Company usually interferes with that. The few times I actually need the <code>lsp-mode</code> plugin to do the work, and list the contents of a namespace, be it a Rust or Python module, a C++ namespace, or any some such, <code>company</code> fails to produce anything. This is not an attack on <code>company</code> specifically, by the way, <code>corfu</code> a package that offers similar functionality, while different is still something I don&#39;t typically use. The built-in <code>C-M-i</code> handles the few cases where I need to use the LSP to traverse a namespace and import a function or method or structure. And the fact that it offers the <em>entire</em> list as a separate buffer, quite neatly dovetails into how the rest of Emacs works.</p><p>It is not, however, completely without advantage. I do keep it in my <code>packages.el</code>, and there are good reasons for that. Firstly, <code>lsp-mode</code> is much more configurable, and actively developed. This means that occasionally you will find features that are either exclusive, or much easier to work with in <code>lsp-mode</code> and not in <code>eglot</code>. Things like <code>inlay-hints</code> that are providing the type annotations are more granular in <code>lsp-mode</code>. The same applies to completions, and while I have made it sound like it opting you into <code>company</code> is a huge deal, I found it easy enough to disable and it simply contributes to the bulk of the configuration file, not necessarily mucking it up.</p><p>Another important aspect of <code>lsp-mode</code> is its support for debuggers. I am primarily programming in Rust. Due to the way in which this programming language is designed, debuggers are both harder to properly set up, and add significantly less value. Most of their added value can be obtained through judicious use of logging, types and unit tests. The fact that you are <em>not able</em> to drop into <code>gdb</code> and step through your program, means that you will leave those diagnostics in, and that your program, if it fails in production, will be much easier to reason about. In effect, using a debugger in Rust-based network programming is a disadvantage. I also write a considerable amount of C++ and there being able to <code>gdb</code> into your program is a godsend. If your tests fail, being able to understand what&#39;s going on is useful too. While it is definitely possible to expand macros with <code>eglot-x</code> for Rust, I find it quite easier to do the same in <code>lsp-mode</code>.</p><p>Another nice-to-have is the integrations that <code>lsp-mode</code> provides. Simply put, there are quite a lot more of them, despite the fact that the API is more &quot;downstream&quot;. For example, <code>lsp-treemacs</code> solves a problem that on <code>eglot</code> I find a bit daunting: the fact that if you make a change in one file, what is broken might be in several other files all across your project. With <code>lsp-treemacs</code>, I simply have a persistent buffer that does things to make it easier for me to find bugs. It&#39;s not like I don&#39;t have options outside of it, but I do have a considerable amount of difficulty navigating without it.</p><h2 id="nolsp" tabindex="-1"><a class="header-anchor" href="#nolsp"><span>NoLSP</span></a></h2><p>This is the point where one would normally get into a conclusion-like section stating that the two approaches have their own strengths and weaknesses and that you should self-identify and figure out what you want to be using.</p><p>I find that this is a rather limiting perspective. Firstly, you can have both installed. Secondly, despite Microsoft&#39;s insistence that their tool does the best job, I found that to be rather untrue.</p><p>The language servers, while a useful tool, are not always the best tool for the job, and one should not overly rely on them. So in this section I shall try to elaborate, and explain what I do for tasks to which you would normally delegate to the LSP.</p><h3 id="go-to-definition" tabindex="-1"><a class="header-anchor" href="#go-to-definition"><span>Go to definition</span></a></h3><p>This is perhaps the single largest reason to use an LSP plugin. It is also one that I tend to go around. Simply put, <code>rust-analyzer</code> is not at all good at finding definitions. Sometimes, it gets out of sync with your editor, and you have to restart the server and re-index in order to find the definition for a function. I simply found that catching the error and delegating to <code>dumb-jump</code> in a language without function overloading does the job really well. Often I don&#39;t even bother with restarting the server or using <code>M-.</code> to use the <code>xref</code> built-ins, but rather use <code>git-grep</code> which with the help of <code>vertico</code> can give me even more insight.</p><p>The only place I have found the <code>lsp-mode</code> based jump to be more accurate is also a case which is handled particularly well with tags. In fact, I found tags to be the preferred path for languages that support them well (not Rust, but <code>dumb-jump</code> is accurate-enough, so not a problem). The reason is simple: <code>rust-analyzer</code> doesn&#39;t persist the tag information to disk, and needs to re-index every time you start the server. Until the initialisation process is complete, at least on Emacs, I have no option but to wait. With tags, the process is almost instantaneous.</p><h3 id="rename" tabindex="-1"><a class="header-anchor" href="#rename"><span>Rename</span></a></h3><p>This may be a controversial topic, but how LSP handles renaming is not quite what is needed. I often found that if a project is well-documented, you don&#39;t just want to rename the one place in the source code that it is mentioned. The <code>projectile</code> package offers a neat way to update all names at once, and given that it is regular-expression based and not sub-string based as most code editors, the number one problem of renaming that way: the fact that you can accidentally rename a sub-string of an unrelated entity, is handled gracefully. Note, that if you <em>do</em> want to change the name of the sub-string as well, you <em>can</em>.</p><p>I also found that <code>lsp-rename</code> and <code>eglot-rename</code> are often inaccurate. They may refuse to rename an entity citing that there is <code>no identifier at point</code>, which you can clearly see is untrue. Restarting the server entails more work, that can simply be avoided if you are comfortable with <code>projectile</code>. And you should be.</p><p>As a final note, the fact that renaming an entity is a bit more involved than just calling <code>lsp-rename</code> tends to ward off frivolous renaming. If you open a pull (merge) request, there are going to be multiple one-line changes for renaming a single entity. These can easily be confused with using the same instance of an overloaded function. It can cause unnecessary fatigue on the reader. If something is poorly named, renaming is potentially an ABI and API breaking change.</p><h3 id="extract-function" tabindex="-1"><a class="header-anchor" href="#extract-function"><span>Extract function</span></a></h3><p>I will say this once and say this in a way that tries to offend as many people as it needs to. You should extract functions manually. If the only reason that you are extracting a function is because your linter is complaining about the thing being hard to read, there are alternatives to extracting a function with a meaningless name that are preferred in my opinion.</p><p>There had been a <a href="http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html" target="_blank" rel="noopener noreferrer">long post by</a> John Carmack that specifically addressed the question of factoring a large state change into smaller functions, is not worth it in most instances. The dis-aggregation (longer post on this in the works), does not necessarily have to happen at the function level. Compound scoped modifications are largely supported by modern languages, and are often <em>just as</em>, if not <em>more</em> effective at dis-aggregating a complex set of state transitions in imperative languages. The few cases where they are not, patterns such as type-state offer a bigger benefit.</p><p>The problem with refactoring in general is that it is largely done for the benefit of other programmers. With the exception of large language models, no automatic method of refactoring I found particularly useful. In most cases complex state transitions should remain complex, and warn the user that there is a large chunk of work that needs to be done quickly and sequentially. Hiding this information does not lead to a better understanding of the code, but to a tough-to-break illusion of simplicity.</p><h3 id="generic-refactoring" tabindex="-1"><a class="header-anchor" href="#generic-refactoring"><span>Generic refactoring</span></a></h3><p>On the note of LLMs, while I do not necessarily find them all that useful for generating code, I do think that they are surprisingly good at rewriting it. My personal set up does not involve either Co-pilot, or ChatGPT. For my benefit, I have a 7900xt that with a properly patched <code>ollama</code> is capable of running things like <code>codestral</code> quite effectively and with reasonable speeds. Its code almost always has to be double-checked, because when you ask it to generate <em>e.g.</em> an <code>impl</code> block for a particular structure, it might actually re-define it, or maybe add a <code>derive</code> on top. You might think that <code>rust-analyzer</code> offers a vastly superior experience; that it would never generate code that wouldn&#39;t compile, or that it can&#39;t possibly mess up another section of the code that has no relation to what you asked it to do, or that indeed, at least it would do it much more quickly. I suppose you should be able to infer the capabilities of LSP as opposed to LLM.</p><h3 id="snippets" tabindex="-1"><a class="header-anchor" href="#snippets"><span>Snippets</span></a></h3><p>One thing to keep in mind is that if you are doing a common task that needs to be syntax-aware, and you cannot afford to waste time with LLMs, you could make use of <code>yasnippet</code> to do just the same. I have found it to be useful for generating <code>mod test</code> blocks, and <code>#[test] fn test_case()</code> functions. It can be made to adhere to specific variables, and if need be, compiled down to a function that is then made available. Furthermore, with the introduction of <code>tree-sitter</code>, I have found that it is possible to extend the native Emacs capabilities with scope-awareness. For the time being, these are prototypes and largely for just one programming language: Rust. But I can foresee that proper extensions to major modes, even as separate packages that make use of the wonderful capabilities that Emacs offers can be <em>just as</em> if not <em>significantly more</em> effective than LSP plugins.</p><p>Simply put the amount of work that it would take me to write a few lines of Elisp is nothing in comparison to the amount of work and reviewing that I would have to do for a small change to be added to an LSP such as <code>rust-analyzer</code>.</p><h3 id="inlay-hints" tabindex="-1"><a class="header-anchor" href="#inlay-hints"><span>Inlay hints</span></a></h3><p>This is a controversial point, because I don&#39;t exactly have a direct analogue to inlay hints. And I must also admit that there are cases where they are genuinely irreplaceable.</p><p>What I do propose is a different approach to finding out the type of something. As I alluded to earlier, there is a capability in Emacs to be able to read the entire buffer. This is a sketch of a function, that in reality is way too ugly to be published, and not used all that often, but could in principle do just as much as the built-in LSP.</p><p>In <em>e.g.</em> Rust, there must be a declaration of a type in order for it to be used. That means that I must look into a limited number of places, nothing is implicitly imported, no variable in a function can be other than an upper-case constant, a lower-case <code>let</code> binding or a function argument. There are subtleties related to pattern matching as well, but for the time being, let us consider them part of the argument family. I can simply find the binding, automatically or otherwise, and go to its definition. In most cases if something is bound from a function call in a <code>match</code> the type is already shown in the prefix. If something is bound in <code>let</code>, it&#39;s a similar story. As a final resort, if your code relies a lot on you knowing what type something is, you can always rely on explicit type annotations.</p><p>What is eminently more clear if you have done a bit of Rust programming, is that many of the commonly used type names are not well-thought-out. Conisder how many times you had to <code>use library::Error</code>. The inlay hints, definitely those provided by <code>eglot</code>, and those that <code>lsp-mode</code> provides by default, more often than not, only provide you with the final segment of the fully qualified name. In case of <code>Error</code> this provides you next to no useful information.</p><p>The limitations are of course, in relation to stream operations and chained method calls much more common in Rust than in any other C-like curly braced language, with the possible exception of Java.</p><h3 id="diagnostics" tabindex="-1"><a class="header-anchor" href="#diagnostics"><span>Diagnostics</span></a></h3><p>This is a rather touchy subject. This is applicable to Rust, but I can foresee how it would be a problem for another language. Simply put <code>M-x compile</code> with <code>cargo check --workspace</code> provides you with a lot more freedom than any LSP can dream of. You get a buffer that enumerates all of the problems, easy keyboard navigation that is often extremely accurate. You do not need, <em>anything</em> else. If a diagnostic tool reports their errors the same way <code>rustc</code> does, (and it should), one can have a lot of instrumentation. For lints, for example one can add tooling to check for the explanation as to why that lint even exists, when it was added, and how to deal with it. It might not show up as a suggestion in <code>rustc</code>, which would also enable you to fix it with <code>cargo &lt;command&gt; --fix</code>, but it would, at least in principle, provide you with a more holistic understanding of the diagnostic at point.</p><p>While I have found that <code>flymake</code> with <code>eglot</code> works well for single file projects and causes a bit of headache when a project is larger, and remedied most of the problems of tracking down every single thing that is wrong with using <code>lsp-treemacs</code> for the diagnostics, the question of having a good explanation remains open. Most language servers do not provide much of an explanation other than a few lines of code. Rust, due to the borrow checker being rather complex had to provide good error messages for everything. Most tools and most language servers did not have that problem, and often in languages like <code>go</code>, a simple error is good-enough.</p><p>However, I often fall back to using <code>cargo check</code> and <code>python main.py</code> for checking for errors. It&#39;s often also the case that a complex set of SFINAE diagnostics can only be parsed in the form in which it is generated by <em>e.g.</em> <code>gcc</code>. Frustrating, but we do not have a good way of either reporting diagnostics via LSP, nor a good way of presenting them in the editor.</p><h3 id="specialised-extensions" tabindex="-1"><a class="header-anchor" href="#specialised-extensions"><span>Specialised extensions</span></a></h3><p>In some situations in <em>e.g.</em> Rust, it is quite convenient to be able to tell what code is being generated by which macro. Macros and <code>derive</code> statements are a wonderful way of obscuring what is happening, and I often found myself wishing increasingly grotesque and amusing fates to the authors of implementations generated by declarative macros. As a consequence, I have found it to be sublimely effective to make use of <code>cargo expand</code>. Usage of such tools is nothing new, but the main issue with it, just like with every major package produced by Mr Tolnay, is that the user experience can be classified as complete dog faeces.</p><p>Being able to place one&#39;s point at a pesky <code>impl_&lt;trait_x&gt;!</code> and see what it expands to is one area where I think the benefits of LSP outweigh the drawbacks.</p><h2 id="honourable-mention-lisps" tabindex="-1"><a class="header-anchor" href="#honourable-mention-lisps"><span>Honourable mention: Lisps</span></a></h2><p>The situation with lisps is radically different than that of other languages. I am not a lisp programmer. For this comparison, made by popular request, I had to start my own adventure with lisps other than the one built into Emacs, and I must say that this is probably the best counter-point to language servers.</p><p>Simply put, <code>sly</code>, <code>slime</code> and the built-in Emacs Lisp support is outstanding compared to what you have in the form of LSP.</p><p>Emacs lisp will force you to use the right tools, it will complain about not having lexical binding, warn you about the fact that your variables might not be bound, so you might think that it&#39;d work, but it might not always. It knows about the subtlety of language, it will complain about the fact that you are describing a function as if it were an object, and tell you to &quot;use the imperative mood, you silly&quot;. Outside of nitpicking, the built-in completion works well. You have a REPL at your fingertips: there&#39;s always <code>M-x</code> for interactive functions, but I find myself leaning onto <code>M-:</code> more and more these days.</p><p>The amount of stuff that LSP can&#39;t do, when put head to head with the most well-worn path in Emacs is astounding. True, Emacs lisp is a bit old-fashioned, and not nearly as friendly for concurrency as one might hope, but the sheer fact that people using one obscure single editor managed to pull off a gargantuan project like <code>org-mode</code> within Emacs lisp is a good indicator of a full integrated development experience.</p><details><summary>Me and Lisps</summary> Put simply, developing in Elisp within Emacs is a joy. The amount of insight that Emacs can provide is astounding, and I&#39;ll be honest, the main reason that I&#39;m not as proficient in any other lisp, is that I&#39;d rather have this out-of-the-box, well-integrated experience, than have a potentially better language with tooling that I&#39;d have to set up. <p>Besides, I&#39;m not lucky enough to a job in lisp. Most of what I do is good old-fashioned Python and Rust, (the joke is intentional, Lisp is one of the oldest families of high-level languages second only to FORTRAN). I do not write lisp for a living and as much as I&#39;d like to, finding a job like that will entail a significant pay-cut.</p></details><p>With Emacs lisp, one other convenience that is often overlooked, is the minimal amount of garbage that is being produced by all of this. True, some of this might be addressed by the new garbage collection proposal, <em>if</em> it is merged into upstream Emacs. However, one should take note of the fact that the LSP standard was not something that is in principle, unique.</p><p>One could, if one were to so choose, extend the protocol by allowing alternative communication methods. For example, if the client-server architecture were retained, but instead of sending JSON, the communication were to be done in <em>symbolic expressions</em>, the amount of garbage, and thus responsiveness of Emacs under these circumstances would be improved.</p><h2 id="faster-lsp" tabindex="-1"><a class="header-anchor" href="#faster-lsp"><span>Faster LSP</span></a></h2><p>Another avenue that has been explored, is building an <a href="https://github.com/manateelazycat/lsp-bridge" target="_blank" rel="noopener noreferrer"><code>lsp-bridge</code></a>. The idea, that is available as a standalone package, is to have a separate sub-process that isn&#39;t Emacs, that translates without much garbage the thing received from the LSP, into something that Emacs can grok.</p><p>Unfortunately, the doing almost nothing fast is not a compelling package. The main issue I found with using <code>lsp-bridge</code> is that it is a separate editor built on top of Emacs. It has the dreaded JSON file as a configuration, requires you to have another Python subprocess to run, and if anything, cuts you off from <code>capf</code>, almost every function in <code>lsp-bridge</code> is a custom function that does not integrate with any other package, much less anything built-in.</p><p>I already find the improvement to the UX of Emacs from LSP to be minimal. Would I trade a slightly faster response time for a significantly worse experience?</p><p>What I find frustrating about this approach is that it solves a problem that is better solved upstream. Instead of simply creating an ad-hoc solution to &quot;JSON generates a lot of garbage&quot; problem, or better yet, use a native binding mode that does not rely on JSON as an intermediary, Emacs could have a simple library that could parse a lot of this and make Emacs suitable to be run as a regular web server (or rather <em>more</em> suitable than it already is).</p><p>Unfortunately (or fortunately, depending on your perspective), this project is nothing if not hard to obtain and hard to work with. It is not present on MELPA. It exists, it&#39;s there and the link to it in this article is as much of an endorsement I&#39;m going to give it.</p><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>Simply put the language servers are just another tool. They have a large benefit in terms of developments happening to language servers being transferable across editors. This is a benefit that largely is irrelevant for Emacs. It is almost never the case that some fancy new, freely available tool is made for another text editor and Emacs is permanently left in the dust. It is quite the opposite, I have found, because writing a few lines of Elisp for a new language to get most things working is much easier than designing a language server.</p><p>The quality of language servers is another matter entirely, something I chose not to touch, and largely focus on one language whose language server I know well. This is because while I have pointed out a few problems with <code>rust-analyzer</code> it is largely a complete program that implements the desired behaviour accurately and completely. I do not wish to tarnish the conclusion of this article by being negative with respect to other language servers.</p><p>This is not a guide as to how to use a language server, that will come in a later article. It is merely an opinion and critical piece on the two major implementations of the language server protocol.</p>',89)]))}const h=t(n,[["render",s],["__file","emacs-lsp.html.vue"]]),d=JSON.parse('{"path":"/posts/emacs-lsp.html","title":"Language servers in Emacs","lang":"en-GB","frontmatter":{"category":["Emacs","Work","Tooling"],"date":["2024-11-03T00:00:00.000Z"]},"headers":[{"level":2,"title":"Language Server Protocol","slug":"language-server-protocol","link":"#language-server-protocol","children":[]},{"level":2,"title":"Eglot and where it shines","slug":"eglot-and-where-it-shines","link":"#eglot-and-where-it-shines","children":[]},{"level":2,"title":"Interlude: technological challenges","slug":"interlude-technological-challenges","link":"#interlude-technological-challenges","children":[]},{"level":2,"title":"LSP-mode","slug":"lsp-mode","link":"#lsp-mode","children":[]},{"level":2,"title":"NoLSP","slug":"nolsp","link":"#nolsp","children":[{"level":3,"title":"Go to definition","slug":"go-to-definition","link":"#go-to-definition","children":[]},{"level":3,"title":"Rename","slug":"rename","link":"#rename","children":[]},{"level":3,"title":"Extract function","slug":"extract-function","link":"#extract-function","children":[]},{"level":3,"title":"Generic refactoring","slug":"generic-refactoring","link":"#generic-refactoring","children":[]},{"level":3,"title":"Snippets","slug":"snippets","link":"#snippets","children":[]},{"level":3,"title":"Inlay hints","slug":"inlay-hints","link":"#inlay-hints","children":[]},{"level":3,"title":"Diagnostics","slug":"diagnostics","link":"#diagnostics","children":[]},{"level":3,"title":"Specialised extensions","slug":"specialised-extensions","link":"#specialised-extensions","children":[]}]},{"level":2,"title":"Honourable mention: Lisps","slug":"honourable-mention-lisps","link":"#honourable-mention-lisps","children":[]},{"level":2,"title":"Faster LSP","slug":"faster-lsp","link":"#faster-lsp","children":[]},{"level":2,"title":"Conclusion","slug":"conclusion","link":"#conclusion","children":[]}],"git":{"updatedTime":1742748808000,"contributors":[{"name":"Aleksandr Petrosyan","username":"","email":"ap886@cantab.ac.uk","commits":6}],"changelog":[{"hash":"2504feacfc8e83978d0f3b7c3a3f7df06b5b48c6","time":1742748808000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Migrating articles"},{"hash":"bc5bda253540556643ed855b2cd5c7ee23c67889","time":1742747283000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[vuepress]: Initial migration"},{"hash":"d91bb031b510fe24743ec3add4ecf1dd55ead528","time":1735165942000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[lsp]: add reference"},{"hash":"cb04c15b6c69aa6b608ad66c4d2c0fc812834053","time":1731234899000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[emacs-lsp]: SLIME"},{"hash":"7bf0f97f662886a2ed513ac4a5468228ef4a8c05","time":1730641187000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[article]: Complete LSP article"},{"hash":"9948be4bbadbd5202ad2de6e96a3796048eec6a7","time":1730626558000,"email":"ap886@cantab.ac.uk","author":"Aleksandr Petrosyan","message":"[article]: Emacs LSP"}]},"filePathRelative":"posts/emacs-lsp.md","excerpt":"\\n<p>In this post I will try to summarise my experience with all things LSP (language server protocol).  I will talk primarily about the two most important implementations of LSP for Emacs: <code>eglot</code> that is built into Emacs, and <code>lsp-mode</code> that seems to be much more feature complete.</p>"}');export{h as comp,d as data};
