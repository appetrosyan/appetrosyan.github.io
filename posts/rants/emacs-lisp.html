<!doctype html>
<html lang="en-GB">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Emacs lisp | Aleksandr Petrosyan</title><meta name="description" content="">
    <link rel="preload" href="/assets/style-DiLsruXl.css" as="style"><link rel="stylesheet" href="/assets/style-DiLsruXl.css">
    <link rel="modulepreload" href="/assets/app-DYOwYO0n.js"><link rel="modulepreload" href="/assets/emacs-lisp.html-O_CUWluz.js">
    <link rel="prefetch" href="/assets/index.html-BYRzIubB.js" as="script"><link rel="prefetch" href="/assets/get-started.html-zuTPU_xC.js" as="script"><link rel="prefetch" href="/assets/blockchain-vs-bank.html-CHdHUi36.js" as="script"><link rel="prefetch" href="/assets/emacs-keybinds.html-BO-FkPb6.js" as="script"><link rel="prefetch" href="/assets/emacs-lsp.html-BFqcOPMf.js" as="script"><link rel="prefetch" href="/assets/emacs-quick.html-BMDTEgLu.js" as="script"><link rel="prefetch" href="/assets/emacs-use-package.html-Cde83Hhe.js" as="script"><link rel="prefetch" href="/assets/failure.html-DO7UUuON.js" as="script"><link rel="prefetch" href="/assets/keepassxc.html-DjWevt62.js" as="script"><link rel="prefetch" href="/assets/lsp-emacs.html-C8nIa5tP.js" as="script"><link rel="prefetch" href="/assets/magit-forge.html-Ct1J7xyb.js" as="script"><link rel="prefetch" href="/assets/privilege-escalation.html-CyYZ-1OC.js" as="script"><link rel="prefetch" href="/assets/young-programmers-advice.html-BEXbJobU.js" as="script"><link rel="prefetch" href="/assets/cat-v-harmful.html-uVtyjVDD.js" as="script"><link rel="prefetch" href="/assets/emacs.html-CHuchXey.js" as="script"><link rel="prefetch" href="/assets/jekyll.html-fCP1louO.js" as="script"><link rel="prefetch" href="/assets/language_elitism.html-DGmSWe-G.js" as="script"><link rel="prefetch" href="/assets/markdown.html-ClhHjTFP.js" as="script"><link rel="prefetch" href="/assets/neovim.html-Cvi6bnAc.js" as="script"><link rel="prefetch" href="/assets/remasters.html-Dagy0tA2.js" as="script"><link rel="prefetch" href="/assets/semver.html-CgJnEB-I.js" as="script"><link rel="prefetch" href="/assets/stallmann.html-jPajK5CQ.js" as="script"><link rel="prefetch" href="/assets/vitepress.html-CEi__-Vn.js" as="script"><link rel="prefetch" href="/assets/404.html-DoA9wFpq.js" as="script"><link rel="prefetch" href="/assets/index.html-R7YPcmKi.js" as="script"><link rel="prefetch" href="/assets/index.html-CXSYajJN.js" as="script"><link rel="prefetch" href="/assets/index.html-CEiFJivq.js" as="script"><link rel="prefetch" href="/assets/index.html-IVj3WCn-.js" as="script"><link rel="prefetch" href="/assets/index.html-Cla28_P_.js" as="script"><link rel="prefetch" href="/assets/index.html-BT45leYG.js" as="script"><link rel="prefetch" href="/assets/index.html-DRoutCwn.js" as="script"><link rel="prefetch" href="/assets/index.html-BxpNuxS_.js" as="script"><link rel="prefetch" href="/assets/index.html-BFsVTUGo.js" as="script"><link rel="prefetch" href="/assets/index.html-D5ldDAh0.js" as="script"><link rel="prefetch" href="/assets/index.html-BsrIXoby.js" as="script"><link rel="prefetch" href="/assets/index.html-DedQfL7z.js" as="script"><link rel="prefetch" href="/assets/index.html-D1A_k18C.js" as="script"><link rel="prefetch" href="/assets/index.html-DbZkiYWr.js" as="script"><link rel="prefetch" href="/assets/index.html-CI_5D_v4.js" as="script"><link rel="prefetch" href="/assets/index.html-CGCNYtN5.js" as="script"><link rel="prefetch" href="/assets/index.html-B5fwex-Q.js" as="script"><link rel="prefetch" href="/assets/index.html-DOvyz3LP.js" as="script"><link rel="prefetch" href="/assets/index.html-D81RHAeO.js" as="script"><link rel="prefetch" href="/assets/index.html-By0dKX9g.js" as="script"><link rel="prefetch" href="/assets/index.html-Bcu_SolT.js" as="script"><link rel="prefetch" href="/assets/index.html-BJYUCb6K.js" as="script"><link rel="prefetch" href="/assets/index.html-C4xlGdiQ.js" as="script"><link rel="prefetch" href="/assets/index.html-CrjQIJ9q.js" as="script"><link rel="prefetch" href="/assets/index.html-4c7imIsQ.js" as="script"><link rel="prefetch" href="/assets/index.html-BdxRAMQt.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="Aleksandr Petrosyan"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Aleksandr Petrosyan</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Emacs lisp <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="emacs-lisp" tabindex="-1"><a class="header-anchor" href="#emacs-lisp"><span>Emacs lisp</span></a></h1><p>This is a blog post dedicated to the configuration language of my favourite editor: Emacs.</p><p>It is true that Emacs owes its flexibility and very configurable nature to this wonderful and awful language. It is both its greatest strength and weakness. It is simply the brick wall that is responsible for the learning curve.</p><p>It is also the major source of the reasons why Emacs can&#39;t be made either asynchronous or multi-threaded. Or at least, not in the usual sense.</p><p>So why keep it around? Why was I one of the few people that was defending Elisp as the configuration language despite Emacs GUILE making a compelling case that it would indeed be better. Why am I writing this blog post?</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>Shout-out to <code>tusharhero</code> who prompted me to answer this question.</p></div><h1 id="overview" tabindex="-1"><a class="header-anchor" href="#overview"><span>Overview</span></a></h1><p>Emacs lisp is a lisp. It is a reverse-polish notation language with a very simple syntax, non-trivial interpreter and many of the features that are associated to &quot;modern&quot; programming, despite those being known, available and ergonomic back in the day of McCarthy. Specifically, you have dynamic typing, garbage collection, functions as values, procedural (and if you will, functional) macros, with every line an expression, with the full language available at load time, compile time and even interpretation time. It can support inheritance, prototype-based object-oriented design, functional programming, and a few other paradigms. The language is remarkably simple.</p><p>Lisp used to have strong connections to academia, so every MIT graduate has to have gone through the Structure and Interpretation of Computer Programs. There are many who know a lot about Lisp. I am not one of them. What follows is not an expert&#39;s opinion on Emacs lisp (experts also think that it is better than most other languages like <code>lua</code> but is generally trash compared to something like Scheme or Common Lisp), but the opinion of a programmer that has a completely different upbringing.</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>I did not learn Lisp until I was already a man</p></div><p>My background is in Pascal, C++ then C, then some Python and finally Rust. Along the way I had a brief academic brush with Standard-ML and self-taught Haskell, but nothing to the extent which would be considered professional. I am proficient in mathematics however, and seriously studied computer science as a second major for as long as I was allowed to at Cambridge. My current work revolves around hard-core computer science and compiler construction. I eventually intend to implement a small systems programming language with a different approach to types, and as such, understanding why people are so resistant to Lisp, and Emacs lisp specifically is a good guide.</p><p>So what does someone who learned Lisp for the first time in their twenties think of it? In the following few sections I will outline the initial learning experience, the challenges, the advantages, and outline a potential road-map to adjust the initial experience so that people are less fazed by it.</p><h1 id="first-boot" tabindex="-1"><a class="header-anchor" href="#first-boot"><span>First boot</span></a></h1><p>Emacs is a graphical program with weird conventions. It shows you a poorly-laid-out welcome screen that sort-of tells you that you should go through a tutorial. And it does teach you how to do the basics that you would normally be able to perform on your own. It does teach you <em>a bit</em> about some &quot;more advanced&quot; topics, like key sequences as command bindings, for example, the fact that you can hit <code>C-x C-s</code> to save, and <code>C-x C-c</code> to quit. We&#39;re not here to discuss this in-depth, but the fact that <em>some</em> but not <em>all</em> of the keybindings follow the CUA conventions is a bit of a problem.</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>Of course, one could have started with Mastering Emacs by Mickey Petersen. I&#39;ve only recently read through the book. I like it a lot, but it is not particularly accessible. It costs money. Money that I did not have at the time I was learning my way around Emacs.</p></div><p>At some point, the user discovers that there is a graphical user interface to both install packages, as well as customize the ones already loaded into the editor. They will not do so quickly, however.</p><p>While I will applaud Emacs for providing something that <code>vim</code> to this day does not: a menu bar and a tool bar (which almost every self-proclaimed Emacs &quot;guru&quot; tells you to disable), the efficacy of both of these is somewhat questionable. First of all, my Emacs set up has <code>File</code>, <code>Edit</code>, <code>Options</code>, <code>Buffers</code>, <code>Tools</code> and then a ton of other entries.</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>We as users are conditioned to ignore the most helpful (no pun intended) menu entry <code>Help</code>. Mostly because software tends to open severely dumbed down, unsearchable mess that is just as likely to get you confused as to help.</p></div><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>If you ever wondered why most modern programs hold you hostage to give you a <em>tutorial</em>, it&#39;s because of this problem. There isn&#39;t exactly a fix; if you add a <em>I&#39;m a pro</em> button to skip tutorials, people with no credentials will click it; get stuck; angry and then you&#39;re back to square one. The only way to avoid this is to cater to the stupidest person that you want as your user, which is tricky.</p></div><p>If the program is designed holistically and has a plugin system, every function that you have access to is accessible from the menu bar. Most frequently used actions are accessible from the toolbar, have a tooltip and show you helpful key combinations. Emacs has that concept, but executes it poorly.</p><p>For one, the key convention is different, more on that later. Secondly, some of these keys are just moronic: my menubar binds all help commands to <code>&lt;help&gt;</code> which, as far as I checked isn&#39;t present on my keyboard. Thirdly, sometimes packages add an entire menubar menu. Sometimes they don&#39;t show up in the menubar at all. If they do, the naming conventions that you would expect from a well-designed program are defenestrated.</p><p><code>Jinx</code> is an excellent example of that: it shows up in the menu called <code>jinx</code>. It shows you three menu entries: <code>correct nearest</code>, <code>correct all </code> and <code>change languages</code> as well as more helpful entries, such as <code>manual</code>, <code>Customize</code> and <code>turn off</code>. The reason I don&#39;t find it confusing, is because I installed this package, I know what it does (and haven&#39;t forgotten it), and I contextualise what it wants me to do within Emacs&#39; concepts. I even know that to type in <code>M-$</code> I actually need <code>M-S-4</code> or <code>Alt + Shift + 4</code>, which was covered by the Emacs tutorial. But if we&#39;re completely transparent, most people that know that much wouldn&#39;t even consider using the menubar for these functions.</p><p>For a more user-friendly environment, you might want to rename the entry <code>Jinx</code> into <code>Spell-check</code>; the menu entries should also be re-named: <code>correct near cursor</code> gives the user a bit more information, and is not even the most informative title that it could receive. <code>correct all misspellings...</code> retroactively gives context to the previous entry, and also lets the user know that this operation is 100% guaranteed to require further input: a shift of modality if you will. Plus, if we are being pedantic, we could show <code>Alt + Shift + 4</code> as the key combination for extra transparency.</p><p>This aside is emblematic of the problem. Emacs has subtle non-conceptual differences that long-time users don&#39;t even notice. We can internalise changing <code>Alt</code> to <code>M-</code> and maybe even figure that out without going through the tutorial. Most of this applies to Elisp, but in a much grander scale.</p><h2 id="a-gentle-introduction-to-elisp" tabindex="-1"><a class="header-anchor" href="#a-gentle-introduction-to-elisp"><span>A gentle introduction to Elisp</span></a></h2><p>The first time a user sees any Emacs lisp is in their init file, when they decide that they want to adjust the editor to work better. In my case it was <code>.emacs</code>, which is not that common these days, but back in the day, it was a big selling point.</p><p>The first line most likely looks like this</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token car">custom-set-variables</span></span>
<span class="line"> <span class="token comment">;; custom-set-variables was added by Custom.</span></span>
<span class="line"> <span class="token comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span>
<span class="line"> <span class="token comment">;; Your init file should contain only one such instance.</span></span>
<span class="line"> <span class="token comment">;; If there is more than one, they won&#39;t work right.</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is a somewhat useful warning to the user: here be dragons.</p><p>The first thing that a person that has never seen <em>any</em> lisp will see is a bunch of settings in parentheses with a quote before them, no comma after, and no delimiter between the values. In other words someone who already knows how JSON works, but barely because they are just starting out, sees something with front-loaded complexity. An example of the rest of the list looks like this</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">(custom-set-variables</span>
<span class="line"> ;; custom-set-variables was added by Custom.</span>
<span class="line"> ;; If you edit it by hand, you could mess it up, so be careful.</span>
<span class="line"> ;; Your init file should contain only one such instance.</span>
<span class="line"> ;; If there is more than one, they won&#39;t work right.</span>
<span class="line"> &#39;(blink-cursor-blinks 3)</span>
<span class="line"> &#39;(blink-cursor-interval 0.3)</span>
<span class="line"> &#39;(c-default-style</span>
<span class="line">   &#39;((c++-mode . &quot;bsd&quot;) (java-mode . &quot;java&quot;) (awk-mode . &quot;awk&quot;)</span>
<span class="line">	 (other . &quot;gnu&quot;)))</span>
<span class="line"> &#39;(cua-normal-cursor-color &#39;bar)</span>
<span class="line"> &#39;(cursor-type &#39;bar))</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, we as long-term Emacs users understand that the <code>&#39;</code> character delineates that the expression needs to be taken <code>quote</code>-d, <em>i.e.</em> you should not replace it with the results of its own evaluation. We also know that lists in Lisp sometimes come with delimiters, and sometimes do not. Because the <code>custom-set-variables</code> form can accept an optional third argument, we know that we shouldn&#39;t use the <code>.</code> to delimit the first element from what it maps to. We even know that in the <code>c-default-style</code> setting we set the variable to a list, which itself has an association.</p><p>This is something that comes naturally to a very particular kind of person. I had originally assumed that the quote was a punctuation mark like in JSON, except it comes before and not after. Assuming that someone can understand Elisp just by looking at it, is like assuming that someone can understand Algol knowing just English, and some mathematics.</p><p>Jonathan Blow, a famous person with some good games, a notable user of Emacs, was quite fond of the fact that the Focus editor was configured in an easy to understand language, and not &quot;some stupid lisp&quot;. He has a point. Moreover, Emacs provides too much noise to be helpful in configuring itself. What would happen if for example, the user made the mistake of using infix notation in one of the customise clauses?</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">&#39;(</span><span class="token car">blink-cursor-blinks</span> <span class="token number">3</span> * <span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>This is clearly a mistake. Yet, it cannot be caught. No error message. You are left to figure it out if and when it breaks. At the same time, up until recently Emacs would happily complain about a missing <code>(provide &#39;init)\n;;; init.el ends here</code> directive. I&#39;m glad the programming language has its priorities straight.</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>Elisp as a programming language does almost everything that people are taught in university <em>not to do</em>, and yet for some reason people speak highly of it!</p></div><p>To a person that is used to VSCode the need to use Elisp for configuration seems rather confusing. They may have been burned with trying to use basic arithmetic, but the real problems don&#39;t stop there. If they were to look up how to do anything in Emacs lisp, they are bound to find at least five ways, all of which have subtle differences that they will not notice until it is too late.</p><h2 id="semantic-ambiguity" tabindex="-1"><a class="header-anchor" href="#semantic-ambiguity"><span>Semantic ambiguity</span></a></h2><p>10Say you looked up how to disable the toolbar (because you were told to do so in a video), you may find h<a href="https://superuser.com/questions/127420/how-can-i-hide-the-tool-bar-in-emacs-persistently" target="_blank" rel="noopener noreferrer">this</a>. It tells you that you can do <code>(tool-bar-mode -1)</code> and you assume, &quot;aha, so I just write what I want disabled and use <code>-1</code> as a convention. OK. Then the next comment tells you to use the <code>customize</code> interface, which you already did. You then see that it disables the tool-bar in a very different way!</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">&#39;(</span><span class="token car">tool-bar-mode</span> <span class="token boolean">nil</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>OK, so I assume <code>tool-bar-mode</code> is a variable, and I write <code>(VARIABLE VALUE)</code> whenever I want to set it to some value? Nope, it&#39;s just that this thing is both a function and customisable thing. They just so happen to share the name.</p><p>Now to make things interesting, you have <code>setq</code>. OK, for the moment, let&#39;s assume that the person is smart enough to recognise <code>set</code> in the name, and ignore the <code>q</code>. How is that different from <code>(tool-bar-mode -1)</code>? I&#39;m guessing that the Zen of Python&#39;s &quot;let there be one obvious way to do one thing&quot; was caused by this situation.</p><p>Let&#39;s be fully transparent, I do not like this one bit. The only way to ensure people don&#39;t end up accidentally breaking their configuration, is if the recommended ways of doing something are identical in behaviour. The only way to ensure that is to disallow <code>setq</code> to customisation variables, and moreover, to enforce that <code>(&lt;thing&gt;-mode -1)</code> always does what it needs to do. That is certainly true of MELPA packages, but not universally true.</p><p>OK. Let&#39;s suppose that we went from changing some basic variables into the meat of things and tried installing plugins. Again, several ways to do it. Some old documentation telling you how to set up <code>use-package</code>. Some newer documentation on the package itself that can sometimes tell you: &quot;hey, to have this package, put this into your <code>init.el</code>&quot; and then gives you something like this:</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> delight</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>But sometimes, you will get a vague statement like &quot;the easiest way to install this package is via MELPA&quot;, and then a 10-step process to fetch it manually and install. Guess what the impatient modern user is going to do.</p><p>Within the <code>use-package</code> forms, there are often redundant specifications: you can have a <code>global-set-key</code> in the <code>:config</code>, <code>keymap-global-set</code> in <code>:init</code>, a <code>:bind</code> with any number of variations in its syntax. MELPA will be nauseatingly pedantic about source code that less than 1% of user will read, and completely ignore standardisation in the README. This is a huge problem that people will run into.</p><h2 id="front-loaded-complexity" tabindex="-1"><a class="header-anchor" href="#front-loaded-complexity"><span>Front loaded complexity</span></a></h2><p>Let us return for the moment to the question of how much complexity is embedded in the simple first line that most likely already exists in your <code>init.el</code>. A good benchmark of the complexity of a language is to gauge how many concepts one needs to work with in order to perform basic operations, a &quot;hello world&quot; if you like. By that logic, the <code>customize-set-varables</code> is a good proxy.</p><p>Here we have the following concepts in Lisp at work:</p><ul><li><code>custom-set-variables</code> is a function.</li><li>It accepts a variable number of arguments.</li><li>Each argument is a list of two or three elements, the first of which is the name of the variable, the second --- the value to which it is being set.</li><li>Optionally one can add a message, to explain <em>why</em> a customisation was made.</li><li>Each argument must be quoted, otherwise the function doesn&#39;t receive the name of the variable and the value, but a list of two values.</li><li>However, you don&#39;t have to un-quote the second value, if it&#39;s a literal value.</li><li>However, you do need to quote the value in a quoted expression to set the value of a variable to something that is a symbol, distinct from a string.</li><li>Your emacs will likely complain about <code>lexical-scope</code> not being added, so you will add it to a comment that seems to be acting not at all like a comment.</li><li>Lists and function calls are not differentiated in syntax. So accidentally omitting the quote when setting <code>tool-bar-mode</code> is going to silently succeed.</li><li>Lisp uses reverse-polish, so setting <code>zoom-size</code> will look something like <code>&#39;(100 . 24)</code>.</li><li>Some lists have strictly two values, and are singled out via <code>.</code> between the values. But they don&#39;t have to be.</li><li>Parentheses are piled at the end of the last piece of the S-expression. This runs counter to the convention of C.</li><li>There is truthiness: <code>nil</code>, <code>-1</code> are equivalent in some contexts. <code>t</code> and <code>1</code> are too. For some reason <code>f</code> doesn&#39;t exist. For some reason <code>t</code> is not quoted. I guess it&#39;s for the same reason why <code>nil</code> isn&#39;t quoted either.</li><li>Because functions and operators are all prefix and parenthesised, <code>-</code> between identifiers is part of an identifier join. Hence kebab case.</li></ul><p>Compare this to an equivalent conceptual load to someone that used a Python dictionary as a configuration variable.</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token builtin">vars</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">   <span class="token string">&quot;blink_cursor_blinks&quot;</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span></span>
<span class="line">   <span class="token string">&quot;c_default_style&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token string">&quot;c++_mode&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;bsd&quot;</span><span class="token punctuation">,</span></span>
<span class="line">	<span class="token string">&quot;java_mode&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;java&quot;</span><span class="token punctuation">,</span></span>
<span class="line">	<span class="token string">&quot;awk_mode&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;awk&quot;</span><span class="token punctuation">,</span></span>
<span class="line">	<span class="token string">&quot;other&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;gnu&quot;</span></span>
<span class="line">   <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">   <span class="token string">&quot;cursor_type&quot;</span><span class="token punctuation">:</span> CursorType<span class="token punctuation">.</span>bar<span class="token punctuation">,</span></span>
<span class="line">   <span class="token comment"># ...</span></span>
<span class="line">   <span class="token punctuation">}</span></span>
<span class="line">   custom_set_variables<span class="token punctuation">(</span>cua_normal_cursor_color<span class="token operator">=</span>CursorType<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> <span class="token operator">**</span><span class="token builtin">vars</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here we have quite a few advanced concepts, but still less than in Lisp.</p><ul><li>Function calls are parenthesised.</li><li><code>custom_set_variables</code> is a function that accepts a variable number of arguments.</li><li>Some of the arguments can be specified via the <code>&lt;arg_name&gt;=&lt;arg_value&gt;</code> syntax.</li><li>Other arguments can be specified via a dictionary.</li><li>Each dictionary is a mapping from a string to a value. Values are dynamically typed. Each entry is separated by a comma. Trailing commas have no special meaning.</li><li>Things in quotes are string literals containing that value. If a thing is un-quoted, and in the input position it <em>must</em> be a string.</li><li>The <code>**dict</code> syntax means, expand the dictionary into a one-entry-per-key variadic argument mapping.</li></ul><p>See, there&#39;s a lot less going on. There is a lot more to Python as a language, but because conceptually speaking, simple operations are relatively simple, you don&#39; have to worry about your programmers working overtime to compensate for the obtuseness of your programming concepts. Are each of them individually something that you can learn? Yes. But it is a time investment, which most active people try to eschew. It is perhaps not a bad idea to assume for the sake of everyone&#39;s sanity that it is better to keep simple operations simple. Elisp doesn&#39;t let you do that too well. Even in <code>use-package</code> conceptually what is going on is not simpler, it is just hidden better, because it is considered internal to the form.</p><h2 id="programming-in-elisp" tabindex="-1"><a class="header-anchor" href="#programming-in-elisp"><span>Programming in Elisp</span></a></h2><p>One of the biggest barriers to learning Elisp as a programming language is its limited use outside of Emacs. Unlike most Scheme dialects and Common Lisp, Emacs lisp is confined in its usage to Emacs itself. There is no standard library that is used indepedently of Emacs, there is no way of embedding it into another language. It simply exists. The only way to ensure that what you are building is going to work on another person&#39;s computer is if they themselves have another instance of Emacs.</p><p>It used to be that Emacs cam pre-installed on Apple computers. Not anymore. On GNU+Linux the GNU Emacs is a shockingly scarce program, while <code>ex/vi</code> are often pre-installed. Because Emacs lisp is interpreted, you can&#39;t even exactly rely on some magnanimous packager to cover the impedance mismatch between what you want, and what you get. To put it simply, writing Emacs packages requires the other party to also be an Emacs user. That used to be the case in most situations but not anymore.</p><p>So one might ask, whether Emacs lisp is a good general programming language? The fact that there is so much good software written <em>in</em> Emacs Lisp, is a testament to the fact that indeed it is. Lua being a vastly more popular far more advantaged programming language can only sometimes match the quality and quantity of packages written in it. So what is the main problem? There is not much of a difference between programming an Elisp package and an Emacs plugin. To borrow a term from my day job, Emacs is the virtual machine, Elisp is the human-redable method of writing Emacs programs and going outside of this ecosystem is practically a death sentence.</p><p>Plus, some conventions that are closely followed by Emacs lisp are quite foreign to programmers from the other langauges. They imply the existence of global state; the thing that every other modern language is trying to reduce the dependency on. Some abstractions leak through. For example, <code>org-rs</code>, the Org mode implementation in Rust that is supposed to be bug-compatible with the implementation in Elisp, the one way to guarantee transfer from Elisp to the world outside, actually replicates the internal state of the Emacs lisp editor. It has the concepts of point, thing at point etc.</p><p>This would not be a problem, if Emacs were indeed a swiss army knife that could in principle solve every problem. The main issue is that Emacs is good for some problems, that map particularly well to text editing, and even some limited forms of graphical editing, but it sucks as a general purpose programming VM. It can&#39;t do web servers, so you can&#39;t exactly write a CMS in Elisp, unless, like me, you are deadset on making it happen, no matter the human cost. It can&#39;t be used as a CMS, so you can&#39;t exactly have a non-static non-(O(n)) blog that you can update easily. My first instinct of writing my blog entirely in org failed for that reason, I simply have to write everything by hand in Elisp.</p><h2 id="the-dead-end" tabindex="-1"><a class="header-anchor" href="#the-dead-end"><span>The dead-end</span></a></h2><p>Emacs lisp functions are anti-functional. They try not to control the global state in fact they encourage you to use global state to pass information between functions. In fact functions themselves are considered part of that state. It is a common pattern to replace one function with another.</p><p>The intention behind this setup is to encourage the person to think about the machine, also think about how these systems interlock and inter-operate. the intention is not to hold the programmer back, the is to encourage the programmer to make mistakes, learn from those mistakes, and to consider these mistakes as domain specific applications. Changing the behaviour of a built-in function is not a problem, it is expected behaviour, as is the usage of global state.</p><p>this is a very different intention than it is behind and language such as rust. rust for example tries to avoid allowing the programmer to make certain kinds of mistakes, ones that are commonly referred to as undefined behaviour. Rust also prioritises long term maintain ability concerns, over the ability to do quick-and-dirty manipulations. The lisp family of languages is preoccupied with allowing the programmer to do what they want, and not concerned with whether what the programmer wants is good for them. This results in a nonchalant usage of things which in other languages would be considered rude, such as allowing mutable state in the global scope to communicate between functions. it dry programming this way you will find that this results in faster better communication, albeit at the cost of making things much harder to decouple later. in lisp,there is no later.</p><p>back when lisp was in it&#39;s infancy, the very idea of having multiple core processors was untenable. It was unthinkable to have sixty four processes, hell unthinkable to have sixty four processors. By the standards of the seventies, the computers we consider ordinary are far superior to the supercomputers of the day. As such parallel programming was not something to even worry about, and thus parallel programming was not catered to. Today however, the fact that Emacs runs in a single thread is a huge problem. This basically means that the program will block every time you run along operation, which precludes that usage as a server, CMS and other areas.</p><p>Python, a programming language which was designed at the proximal time, is considered the golden standard for single threaded applications. There is no place, no scenario, no situation scribe in which a person who knows the more popular language would be compelled to use Lisp. And now consider that the lisp in question is not even considered good.</p><h2 id="corollary" tabindex="-1"><a class="header-anchor" href="#corollary"><span>Corollary</span></a></h2><p>This whole begs the question, is it even worth learning in this day and age? For me it does, as it covers too many problems which would be otherwise harder to solve. The are far too many packages which already do what I need, what I do not consider myself a good lisp programmer, I feel that I could if I were compelled to solve a new problem that I could write it in Lisp.</p><p>But it would not ascribe as much of the success to the fact that it (Emacs) is using as an esoteric language from the seventies. I firmly believe that it is more of the architecture of the editor itself that results in such a mix of such a flexibility and package variety. Simply put all of what makes lisp great, has been added to other programming languages, and what doesn&#39;t work has been compensated for very well. The new editor which gave you the same kinds of flexibility, but offered much more of an approachable programming languages as a configuration medium would easily overtake Emacs. And indeed so has done VSCode. It is a modern day successor, though it offers less flexibility and JavaScript is considered a far worse language, it has all the building blocks that made Emacs great at the time.</p><p>What resulted in its meteoric rise was not so much the fact that it was better, as it is far too under-developed to be in any way better, but the fact that most programmers felt at home in its configuration. Hacking on VSCode is just as easy as doing web development. Though one may rightfully argue that developing for the web is not in any way easy, and that there are many subtleties, these are all problems that had been solved elsewhere, leaving VSCode to reap the benefits. Emacs, on the other hand had to fight for every minute optimisation. Every package that was built for it, was built <em>specifically for it</em>.</p><p>Emacs lisp still has a place in this world, if and when we at least admit that there is a problem. We can start by admitting that the documentation Emacs provides is good, but it could be much better. To give you an example, consider the package <code>helpful</code>. What it does, is it tries to cram as much information about a specific function as it can into a single buffer. You asked for knowledge, and you received a relatively good explanation. But there are flaws. The formatting is a bit all over the place. There have been major strides in this area, given that the old way of doing things: a plain-text buffer with no markup is no longer the default. Still a way to go. The same is doubly true of the official <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Conditionals.html" target="_blank" rel="noopener noreferrer">Emacs lisp reference</a>; I will not argue that it is ugly, but I will argue that it is a bit dry.</p><p>Then there&#39;s the question of there not really being good Emacs lisp books. Sure, there is Mickey Petersen&#39;s book on how to master the Emacs program, but not a place where the wisdom about Emacs lisp programs is assembled. There is no primer on writing themes either, and while the basic graphical UI that is built into Emacs allows for a ton of customisation, converting it into a theme package is one area where we have much to improve upon.</p><p>What do I mean by a book? Suppose that I wanted to write a program and I needed the equivalent of the <code>switch</code> statement of C in Emacs lisp. I would have to comb through many symbols that do not look like what I need. At the same time, the correct symbol: <code>cond</code> has a name that you wouldn&#39;t necessarily even know to consider (the same is true of <code>setq</code>, <code>set</code> and <code>setf</code>, which the person has no idea how to use).</p><p>Secondly, the phrasing &quot;Try each clause until one succeeds.&quot;, tells me next to nothing about how it actually works. It&#39;s fine for a formal mathematical textbook, but there are much better ways of explaining what this form does to a programmer even in the API documentation format. The word <code>try</code> is overloaded in programming contexts, &quot;evaluate&quot; has strictly one, and it&#39;s the correct interpretation in this context. If one wanted to retain the slightly informal nature of the documentation, one could say &quot;Conditionally evaluate one of many clauses&quot;. This tells the user more and overloads their head less. Plus the the word &quot;Conditionally&quot; being the first in the description allows for a mnemonic for someone that is just trying to learn the language.</p><p>I can give you more examples. I worked as a technical writer could tell you more about being clear about the intent of a language construct. Suffice it to say, some areas of the documentation could use a bit of polish.</p><p>Secondly, and perhaps more importantly there should be more examples. For me, this itch is scratched by <code>helpful</code>, but it usually gives you real-world examples from the packages that you already have installed, as opposed to annotated examples. If it were up to me, the documentation would look something like this:</p><div class="language-lisp line-numbers-mode" data-highlighter="prismjs" data-ext="lisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">cond</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token boolean">nil</span> <span class="token punctuation">(</span><span class="token keyword">message</span> <span class="token string">&quot;this is false, so not evaluated))</span>
<span class="line">  (t (message &quot;</span>this gets evaluated<span class="token string">&quot;))</span>
<span class="line">  (t (message &quot;</span>This is true, but won<span class="token quoted-symbol variable symbol">&#39;t</span> be evaluated&quot;<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Best practices are also an important aspect. Because of the fact that Lisp is a different beast, what is good in it, is bad in other languages, as such the documentation should fill in the gaps and define a style. The editor is quite keen on insisting on some style, so why not give the same treatment to the rest of the packages.</p><h2 id="the-emacs-lisp-manual" tabindex="-1"><a class="header-anchor" href="#the-emacs-lisp-manual"><span>The Emacs lisp manual</span></a></h2><p>Around six authors, including the GNU project&#39;s initiator, Richard Stallmann have authored a book that I am torn on. I would be lying if I said that the book is easy to read, I found mathematical textbooks to be easier to read due to rigour and precise language; more lay-person oriented books focus on conveying the ideas as simply as possible and ignore details that are not pertinent to being proficient. This book, despite my sympathy towards its authors is neither; it somehow managed to find a sweet-spot of being neither particularly useful for people who are already well-versed in Lisp, nor to those that would find Emacs particularly challenging. This book simply <em>is</em>, and can supplement one&#39;s knowledge. It can be used to find imprecise and outdated answers to questions that are much easier to phrase as search queries.</p><p>To add insult to injury, rather than making the book as concise as possible, the main reason behind the formal style; the book is enormous, and looking through the contents, I already envisioned pages that I would be skipping. The book is god-awful, and is a telling reminder that despite Prof. Stallmann being an avid linguistic enthusiast, his communication skills are sorely lacking. I do not claim to presume to be much better at this, but this blog is largely a run-up towards improving the writing to a point to which I could be writing a book. I have one in the works, and I will do my best to at least have a human readable introduction.</p><p>The main problem as I see it, is that this book does not in any way address the problematic aspects. Most people are not well-versed in Lisp. The documentation must acknowledge this, and explain things with many examples. The reason why this is important, is the precise reason why <em>any</em> mathematical book worth its price, will come with exercises, proofs and explanations. For each concept there must be an example, and a counter-example. Again, don&#39;t mean to self-advertise, but this is what I was trying to do in my book on Rust.</p><h1 id="so-why-is-there-so-much-elisp" tabindex="-1"><a class="header-anchor" href="#so-why-is-there-so-much-elisp"><span>So why is there so much Elisp</span></a></h1><p>This begs the question: why is there <em>any</em> Emacs lisp. After all all throughout this article I have been providing scathing reviews of everything that is related to the lisp. Why do veterans still prefer to create their packages for this venerable editor as opposed to anything else new?</p><p>Tough question, I should say. And I do have an answer, that I find less satisfying than I&#39;d like. But nonetheless an answer.</p><p>First of all, one must remember the abhorrent state of graphical programs on GNU + Linux, or as I call it now, lip-service to freedom. If I wanted to create a program for KDE specifically, there&#39;s a good chance that some user of Gnome will want to use it (because nobody else created an analogue for Gnome), complain about it, and create an aura of negativity. KDE programs, do not prevent themselves from being run on other desktops, but also do little to bridge the gap. The programmer, thus, has to bridge the differences themselves.</p><p>Case in point, I have an idea for a voice transcription program. I know exactly how to create the business logic, and I have some experience in using UI toolkits. If I wanted to target Mac OS, I have but one realistic choice: write it in Swift and use the system libraries. If I wanted to do the same with Windows, there&#39;s a bit more choice, but if I want to have the broadest compatibility, there is a native toolkit that looks decent for utilitarian programs, metro if I wanted to make it as shiny and messy as possible, and Qt to make my life less painful. On Linux, I do not have a choice that is guaranteed to satisfy everyone. Qt has more features and is generally more powerful. GTK is more ubiquitous, but perhaps has too many residents of an insane asylum at the helm. TK is so old as to be irrelevant and in some ways too slow. Plus, many things such as access to the keyboard, to the network stack, and to the system tray, come down to a broad spectrum of traps posing as choices.</p><p>Instead of having one program that covers all the needs of a specific niche, you have hundreds of programs that each individually cover 50% of the territory, can&#39;t coexist, and therefore cannot give you complete coverage. The few exceptions to this, are <code>systemD</code>, <code>emacs</code> the browsers, <code>ffmpeg</code>, <code>vlc</code>, and <code>blender</code>. As you can probably tell, the fact that these are also the most prolific libraries and platforms is no coincidence.</p><p>Simply put, the energy one would have to put into writing a <code>systemd</code> unit, is less than a more &quot;theoretically sound&quot; process supervision suite such as <code>s6</code>, not to mention that there is at least some documentation that is somewhat useful for the former, and next to none for the latter. Similarly, despite its many shortcomings in terms of rendering fidelity, <code>vlc</code>, offers a unified package that can handle all of multimedia. It is not <em>a player</em>, it is something that can plug all multimedia-sized holes in your life. I did not like it, I still do not, but I have had to use it, because in some situations having this Swiss-army-knife of a tool is extremely handy. It might suck as pliers, or scissors and be a bad knife, but if the number of tools that you can bring with you is limited, you practically have no choice.</p><p>Emacs, is kind of an interesting counter-example. It is by far closer to Blender and FFMpeg, in that it does offer a platform, but aside from a few kinks in the main executable, is actually fairly sound. You have robust text processing and a robust, well-tested concept of a buffer. You have packages that can clearly interact with each other and can be made both compatible and in-compatible. It offers you a quick and dirty way to create a menu, which would otherwise be much harder. It offers even some rudimentary graphical programming capabilities, not enough to build a fully-functional browser, but enough to browse text-only HTML sites. Emacs can plug all your plain-text-sized holes, it is supremely good at writing prose, it integrates well with LSPs, and offers two different approaches to that. Emacs gives you networking that is guaranteed to work on all platforms, which is quite a bit more than what Qt can say.</p><p>It is easy to extrapolate that all of the problems that programmers have to deal with in Elisp are preventing serious programmers from working on serious projects, but quite the opposite is true. A veteran such as Minad, or Prot, or any one of the Emacs core contributors for that matter, finds the problems just part of the job. Elisp is just like any other Turing-complete programming language, do enough work in it, and you will stop noticing its quirks. Do a bit more, and they cease to be problems, but more opportunities. The fact that everything is a textual buffer is a great help when you&#39;re building a program such as <code>magit</code>.</p><p>The fact that you do not need to cater to less refined users liberates you from having to write code that is intuitive to grasp; you can rely on the person on the receiving end, understanding that they can simply look at the source code for some things. And this lets you create programs with a higher skill floor and ceiling. If there were an attempt to create Magit, but as a desktop application, there would be plenty of other work that would be far too much. As it stands, the simple amount of interconnectivity that Emacs offers as a hub, lets you be what you are, a programmer, who has some additional programs that can do some additional things. Simple as that. If one were to try and reimplement Magit in a different language, it would result in the program itself being far more widely used, but be far less acceptable.</p><p>Consider that Magit actually does not tell you what to do. The fact that <code>TAB</code> can do anything is itself a bit of a stretch.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated:: </span><time class="meta-item-info" datetime="2025-03-23T17:39:04.000Z" data-allow-mismatch>23/03/2025, 17:39</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: ap886@cantab.ac.uk">Aleksandr Petrosyan</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-DYOwYO0n.js" defer></script>
  </body>
</html>
