<!doctype html>
<html lang="en-GB">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Declarative configuration in Emacs | Aleksandr Petrosyan</title><meta name="description" content="">
    <link rel="preload" href="/assets/style-7WH1kDPs.css" as="style"><link rel="stylesheet" href="/assets/style-7WH1kDPs.css">
    <link rel="modulepreload" href="/assets/app-Cs446qsf.js"><link rel="modulepreload" href="/assets/emacs-use-package.html-C2hDyTYi.js">
    <link rel="prefetch" href="/assets/index.html-Oaw2JV53.js" as="script"><link rel="prefetch" href="/assets/get-started.html-DUY-2Mqq.js" as="script"><link rel="prefetch" href="/assets/blockchain-vs-bank.html-C80PJZIj.js" as="script"><link rel="prefetch" href="/assets/emacs-keybinds.html-Bn80gjeK.js" as="script"><link rel="prefetch" href="/assets/emacs-lsp.html-BCn3M5sc.js" as="script"><link rel="prefetch" href="/assets/emacs-quick.html-BGD0yUgD.js" as="script"><link rel="prefetch" href="/assets/emacs-widget.html-Be8nJJzn.js" as="script"><link rel="prefetch" href="/assets/failure.html-CGmWZrrQ.js" as="script"><link rel="prefetch" href="/assets/keepassxc.html-bYsYcJ2s.js" as="script"><link rel="prefetch" href="/assets/lsp-emacs.html-DGgkx7V4.js" as="script"><link rel="prefetch" href="/assets/magit-forge.html-DcEKCxbw.js" as="script"><link rel="prefetch" href="/assets/privilege-escalation.html-Ctblmq_w.js" as="script"><link rel="prefetch" href="/assets/young-programmers-advice.html-DHep_rxF.js" as="script"><link rel="prefetch" href="/assets/cat-v-harmful.html-SPMhfCwC.js" as="script"><link rel="prefetch" href="/assets/emacs-lisp.html-BaMJcjgN.js" as="script"><link rel="prefetch" href="/assets/emacs.html-voE46wgF.js" as="script"><link rel="prefetch" href="/assets/jekyll.html-B5GE8FKB.js" as="script"><link rel="prefetch" href="/assets/language_elitism.html-FRAtjyiw.js" as="script"><link rel="prefetch" href="/assets/markdown.html-CejlSCb7.js" as="script"><link rel="prefetch" href="/assets/neovim.html-DypF6wzu.js" as="script"><link rel="prefetch" href="/assets/remasters.html-CHb___EQ.js" as="script"><link rel="prefetch" href="/assets/semver.html-CB9pLjqW.js" as="script"><link rel="prefetch" href="/assets/stallmann.html-BbhpSYzO.js" as="script"><link rel="prefetch" href="/assets/vitepress.html-HHadzVEd.js" as="script"><link rel="prefetch" href="/assets/404.html-CCw5dXBb.js" as="script"><link rel="prefetch" href="/assets/index.html-CzhxW_Di.js" as="script"><link rel="prefetch" href="/assets/index.html-Cb01gIKy.js" as="script"><link rel="prefetch" href="/assets/index.html-DEnFjvm1.js" as="script"><link rel="prefetch" href="/assets/index.html-D82MSC06.js" as="script"><link rel="prefetch" href="/assets/index.html-B7KJZ7_E.js" as="script"><link rel="prefetch" href="/assets/index.html-BSu7FhAX.js" as="script"><link rel="prefetch" href="/assets/index.html-DjdVwnpP.js" as="script"><link rel="prefetch" href="/assets/index.html-D0NUQ3O1.js" as="script"><link rel="prefetch" href="/assets/index.html-nNiN5Uf4.js" as="script"><link rel="prefetch" href="/assets/index.html-BDT_b_-r.js" as="script"><link rel="prefetch" href="/assets/index.html-DljJS3SE.js" as="script"><link rel="prefetch" href="/assets/index.html-DgZFNqY_.js" as="script"><link rel="prefetch" href="/assets/index.html-sMVxHcYn.js" as="script"><link rel="prefetch" href="/assets/index.html-CpcNPDmM.js" as="script"><link rel="prefetch" href="/assets/index.html-kaIaArBs.js" as="script"><link rel="prefetch" href="/assets/index.html-Dww2gG79.js" as="script"><link rel="prefetch" href="/assets/index.html-B2N5MhfM.js" as="script"><link rel="prefetch" href="/assets/index.html-BNP38DHX.js" as="script"><link rel="prefetch" href="/assets/index.html-DiWLt3v4.js" as="script"><link rel="prefetch" href="/assets/index.html-DWsU4880.js" as="script"><link rel="prefetch" href="/assets/index.html--2bN0HbK.js" as="script"><link rel="prefetch" href="/assets/index.html-DcjARl5h.js" as="script"><link rel="prefetch" href="/assets/index.html-BqNdbXvU.js" as="script"><link rel="prefetch" href="/assets/index.html-DuNm0Fyf.js" as="script"><link rel="prefetch" href="/assets/index.html-D1MIU1La.js" as="script"><link rel="prefetch" href="/assets/index.html-CCQG2Xzu.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="Aleksandr Petrosyan"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Aleksandr Petrosyan</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Declarative configuration in Emacs <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="declarative-configuration-in-emacs" tabindex="-1"><a class="header-anchor" href="#declarative-configuration-in-emacs"><span>Declarative configuration in Emacs</span></a></h1><p>In Emacs, it is often easiest to install a package in one&#39;s initialising configuration file; also known as <code>init.el</code>, usually located at <code>~/config/emacs/init.el</code>, but also historically at <code>~/.emacs.d/init.el</code> as under a different name <code>.emacs</code>.</p><p>This file is responsible for reading your persistent configuration and is often written to by your resident Emacs binary, on first launch and after you&#39;ve made some customisations. It is configured in Lisp, which is both a data representation format (Symbolic expressions), and a programming language.</p><p>Some of the customisations pertain to the Emacs built-in functionality, and when we come to <code>eglot</code> we&#39;ll see how that goes, but some packages, specifically, <code>lsp-mode</code> are not included in the somewhat large binary that <em>is</em> Emacs these days, so they need to be installed externally. That is basically what <code>use-package</code> is doing.</p><p>It is not a package manager, but more of a method to keep your configuration file tidy. It allows you to declare configuration that is local to a specific package, so that you could, in theory at least, remove the entire form and have a clean and working configuration file.</p><p><code>use-package</code> for <code>vim</code> users is like both <code>lazy</code> and a weird package-specific configuration template syntax. It is quite weird by Emacs standards as well, and not <a href="https://protesilaos.com/codelog/2022-12-19-re-questions-use-package-emacs/" target="_blank" rel="noopener noreferrer">universally well-regarded</a>. My personal thoughts are that it is standard enough, that people should default to it, and only under some circumstances opt for something else. Unlike <code>vim</code>&#39;s audience which is split down the middle on vimscript versus lua, and then fragmented further into specific package managers, with <code>lazy</code> being my personal favourite, Emacs is remarkably centralised. This has benefits, you can usually grab code directly from the README and it would work.</p><p>The main drawback is that you do need some baseline proficiency in Emacs. I will try to be as newcomer friendly as possible, targeting the level of knowledge that I developed when I was determined to use Emacs full time, but before obtaining any major skills.</p><h2 id="basic-installation" tabindex="-1"><a class="header-anchor" href="#basic-installation"><span>Basic installation</span></a></h2><p>Suppose you found this neat little package X on the web. And it says in installation that you can install it from GNU ELPA. Well, now you have a classic case for using <code>use-package</code>.</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> X</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>is all you need. You can write this anywhere in Emacs, yes even in your current Rust code project, and hit <code>C-x C-e</code> when you&#39;re at the closing parenthesis (or <code>C-M-x</code> if you&#39;re inside the form. What will happen, is that Emacs will show that it contacted some internet resources, with the intention of downloading the package. At some point it will have installed and you&#39;re golden.</p><p>Now obviously, you may want to know what <code>:ensure t</code> means. It is the rough equivalent of <code>&quot;ensure&quot;: true</code> in a Python dictionary, or JSON. <code>t</code> is the conventional value for <code>true</code>. Though others as we shall see, are acceptable values for that form, using them is usually a bad idea, unless you know precisely what it does. The reason is that Lisp is loosely typed. You can have polymorphic values like <code>t</code>, or a list, or a structure, or many other things.</p><p>Now, <code>ensure</code> in this case should be read is &quot;if it&#39;s not installed already, install it&quot;. As you can expect, this will install the latest version that is available in the package archives. This does not usually result in upgraded packages, and it&#39;s highly recommended to keep them up to date manually.</p><p>So what packages can you install that way? See for yourself, <code>M-x list-packages</code>. All the known package archives are scraped, indexed and all the available packages are listed. From this interface you can install the packages that you want, but if you do it <strong>that</strong> way, your configuration will become messy. Nothing wrong with it, but most people prefer to do it the other way.</p><h2 id="expanding-the-scope-of-available-packages" tabindex="-1"><a class="header-anchor" href="#expanding-the-scope-of-available-packages"><span>Expanding the scope of available packages</span></a></h2><p>There are two major ways to extend the scope of packages available for installation on Emacs. The first and up until very recently the main way is to enable the MELPA and NON-GNU ELPA (Emacs Lisp Package Archive).</p><p>The way to do it that works in my configuration file is</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">require</span> <span class="token quoted-symbol variable symbol">&#39;package</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">;; Any add to list for package-archives (to add marmalade or melpa) goes here</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token car">add-to-list</span> <span class="token quoted-symbol variable symbol">&#39;package-archives</span></span>
<span class="line">			 <span class="token punctuation">&#39;(</span><span class="token string">&quot;MELPA&quot;</span> <span class="token punctuation">.</span></span>
<span class="line">			   <span class="token string">&quot;http://melpa.org/packages/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token car">package-initialize</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is normally enough for 99% of the packages that you would want to install. I try to post mine to MELPA as soon as they&#39;re ready. Another good reason to stop at this is because MELPA packages go through a thorough vetting process and will not get accepted if they have major problems such as gathering user data, doing something nefarious with one&#39;s machine, misuse the Emacs APIs or just contain plain low-quality code with poor naming conventions. I&#39;ve gone through this process more than once, and I trust most of my <code>use-package</code> forms a lot more because of it.</p><p>I will say that this is not the only form that I have. To test my own packages, I often use the <code>:vc</code> keyword, which is fairly straightforward.</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> disposable-key</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:vc</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token lisp-property property">:url</span> <span class="token string">&quot;https://github.com/Greybeard-Entertainment/disposable-key.git&quot;</span></span>
<span class="line">		<span class="token lisp-property property">:branch</span> <span class="token string">&quot;barba&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>:vc</code> lisp form is equivalent to</p><div class="language-json line-numbers-mode" data-highlighter="prismjs" data-ext="json"><pre><code><span class="line"><span class="token property">&quot;vc&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token property">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://github.com/Greybeard-Entertainment/disposable-key.git&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;branch&quot;</span><span class="token operator">:</span> <span class="token string">&quot;barba&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>which as you can already tell is quite easy to grasp. Most modern languages differentiate between elements in a list <code>[ ... ]</code> and fields in a structure <code>{ ... }</code>, while Lisp uses parentheses for both. Sometimes, you will see an odd square bracket, but that&#39;s a rough equivalent of a list, it&#39;s just stored differently. So for any package that you fancy, including your own code, you can simply install it from a <code>github</code> repo, same as with <code>vim</code>. The major upside, being that MELPA offers a high standard of baseline quality.</p><h2 id="recommended-zero-configuration-packages" tabindex="-1"><a class="header-anchor" href="#recommended-zero-configuration-packages"><span>Recommended zero configuration packages</span></a></h2><p>This is a curated list of packages which in my opinion do not require any configuration beyond the basics.</p><h3 id="rmsbolt" tabindex="-1"><a class="header-anchor" href="#rmsbolt"><span><code>rmsbolt</code></span></a></h3><p>Most packages are incredibly easy to install, and here are some examples. <code>rmsbolt</code> adds a function that you can call with <code>M-x</code> that gives you the local disassembly of the binary program that you&#39;re viewing. It&#39;s not as sophisticated as the compiler explorer, but if you know how to read assembly, you get most of the benefit, without also having to strip your project down to compile in the window. That is, it can be used for production code, and not some examples. This is quite an important distinction, because I often have to argue about compiler optimisations for things which are specifically exposed to the compiler.</p><h3 id="key-quiz" tabindex="-1"><a class="header-anchor" href="#key-quiz"><span><code>key-quiz</code></span></a></h3><p>Quite a useful package. It is not as impressive as the others, but you will start feeling its presence if you get into the habit of doing a drill or two a day. I did not have it, when I got started with Emacs, and I wish packages like it were considered more early in development. Obviously the Emacs tutorial and books such as Mastering Emacs are great at giving you a more holistic understanding of the core essentials, but I also have many packages which provide far too many functions to list.</p><h3 id="vundo" tabindex="-1"><a class="header-anchor" href="#vundo"><span><code>vundo</code></span></a></h3><p>Just a powerful reminder of the difference between Emacs and other editors. This package provides a command <code>vundo</code>, which would let you traverse the various states that your current file is in, based on the <code>undo</code> history. In situations where something like a version control system <em>e.g.</em> <code>git</code> are not reasonable, this package helps quite a bit.</p><h3 id="simple-httpd" tabindex="-1"><a class="header-anchor" href="#simple-httpd"><span><code>simple-httpd</code></span></a></h3><p>This is not as useful if you plan to use <code>python</code>, and probably a lot less documented. But I like it.</p><h3 id="diminish" tabindex="-1"><a class="header-anchor" href="#diminish"><span><code>diminish</code></span></a></h3><p>It is not useful on its own and it doesn&#39;t provide a function that you can call with <code>M-x</code> but instead it is a package that will be useful for the rest of this tutorial.</p><p>It removes a small notification at the bottom panel of Emacs, known as the mode line. These are initially very useful, but you will soon find that many packages, including mine, don&#39;t provide a meaningful interaction with the mode-line &quot;lighter&quot;, though some do. To differentiate between those modes that provide a lighter by convention, I will add the <code>:diminish</code> keyword in the <code>use-package</code> forms.</p><h2 id="configuration-basics" tabindex="-1"><a class="header-anchor" href="#configuration-basics"><span>Configuration basics</span></a></h2><p>The only other two keywords from <code>use-package</code> that you <strong>need</strong> are <code>:config</code> and <code>:init</code>. There is a subtle difference, but for the time being, consider them as universal keywords that state that everything after them, is to be executed verbatim, when the package is loaded.</p><p>There are a few typical cases for how this is supposed to be operated. There are some packages that need to be enabled in addition to being installed to take effect. A good example of this is <code>dirvish</code>.</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> dirvish</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:config</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">dirvish-override-dired-mode</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We already know that <code>:ensure</code> installs the package if it&#39;s not installed, and for the package to take effect, you call <code>dirvish-override-dired-mode</code>. By convention, functions that end in <code>-mode</code> toggle the behaviour if called without any arguments. To have more certainty, you could modify the call to look like <code>(dirvish-override-dired-mode +1)</code>. This, conventionally modifies the mode to be enabled if not already, and to stay enabled. Similarly, <code>(dirvish-override-dired-mode -1)</code> would unconditionally disable that mode.</p><p>Quite useful I must add.</p><p>Almost everything that you would want to do with <code>use-package</code> you can accomplish with the <code>:config</code> keyword, though obviously using the purpose built keywords has its advantages, one key benefit that is not replicated in any other editor, is that you can evaluate the forms written in <code>:config</code> regardless of the surrounding context and they will still work as intended. Specifically, you can put the cursor after <code>(dirvish-override-dired-mode)</code> but before the overall closing parenthesis (again Lisp convention), and hit <code>C-x C-e</code>. This will, show you messages in the <code>*minibuffer*</code> about the mode being enabled, then disabled, then enabled again, depending on how many times you evaluate it.</p><p>One key benefit of not writing this code outside the <code>use-pacakge</code> forms, is that if you add <code>:disable</code> keyword to it, that code will not be evaluated. This allows you to keep historical configurations for older packages, without them necessarily slowing the startup time of your Emacs (which is probably symptomatic of an XY problem, but we&#39;ll talk about optimal usage later).</p><p>Now in some cases, you might want to have a few variables set within the configuration, for example</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> cape</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:init</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">add-to-list</span> <span class="token quoted-symbol variable symbol">&#39;completion-at-point-functions</span> <span class="token quoted-symbol variable symbol">#&#39;cape-file</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>For the package <code>cape</code> to work, which is a completion package, you need to add <code>cape-file</code> to the list of <code>completion-at-point-functions</code>, <em>i.e.</em> functions that get called to get completion candidates for the current cursor (point) position. But, that doesn&#39;t mean that you cannot, for example.</p><p>A similar form is for <code>dumb-jump</code></p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> dumb-jump</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:config</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">add-hook</span> <span class="token quoted-symbol variable symbol">&#39;xref-backend-functions</span> <span class="token quoted-symbol variable symbol">#&#39;dumb-jump-xref-activate</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This adds a package-provided function to another list, list of functions that get executed once the <code>xref</code> built-in mode is activated and loaded.</p><p>In fact, <code>-hook</code> lists are quite common and quite useful, used extensively enough to have their own keyword that we shall talk about later.</p><p>Incidentally, what this does is also important to understand. <code>dumb-jump</code> is a very basic provider for the <code>jump-to-definition</code> facilities that Emacs comes with. Instead of providing its own <code>dumb-jump</code> to definition, it instead relies on the fact that you will use <code>xref-find-definitions</code> and other related functions and all that this package, <code>dumb-jump</code> provides is a way to obtain the information in cases where you might have no other source, for example, if you use a very esoteric language. I found it very useful for dealing with Rust projects, because the heuristic needed to jump to definitions locally is actually quite simple thanks to the language design.</p><h3 id="the-hook-keyword" tabindex="-1"><a class="header-anchor" href="#the-hook-keyword"><span>The <code>:hook</code> keyword</span></a></h3><p>This is a very easy to understand keyword. Suppose you want some function to be executed right after a mode is enabled. For example, you want to enable an auto-format-on-save package that is extremely fast, called <code>apheleia</code>. You know that you are mostly going to work with Rust, C, C++, Emacs lisp and don&#39;t know if there are good autoformatters for other languages, so even though you could <strong>theoretically</strong> autoformat Python, you&#39;d rather do it manually.</p><p>Well, this is the right job for the <code>hook</code> keyword.</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> apheleia</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:delight</span></span>
<span class="line">  <span class="token lisp-property property">:hook</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">rust-mode</span> <span class="token punctuation">.</span> apheleia-mode<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">emacs-lisp-mode</span> <span class="token punctuation">.</span> apheleia-mode<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">c-mode</span> <span class="token punctuation">.</span> apheleia-mode<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">cc-mode</span> <span class="token punctuation">.</span> apheleia-mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now can lisp go five minutes without introducing weird syntax? Unfortunately no. But mostly for good reasons. Remember I told you that <code>:ensure t</code> can be considered the rough equivalent of <code>&quot;ensure&quot;: true</code>? While I didn&#39;t exactly lie, that <em>roughly</em> is doing a lot of work. Lisp is largely unlike any other language, while some features were eventually adopted into other languages, most were not.</p><p>The thing that goes after <code>:hook</code> in this case is a list of lists. The lists are all two element wide, and the first element is the hook, the second element is the function that is to be called when that hook is triggered. So, specifically, we run the same mode, <code>apheleia-mode</code> for each of the <code>rust-mode</code> <code>emacs-lisp-mode</code> and so on.</p><p>Now, we&#39;ve seen how to <code>add-hook</code> in the <code>:config</code> form, and it&#39;s quite different, but why is that? <code>use-package</code> is a macro. It takes things that look like code and converts them into actual code. It just so happens that the code that you would write in order to install a package if it&#39;s not already installed is always the same, so it makes sense to hide it inside a macro. So does it make sense to hide the common boilerplate for the actual invocation of adding a function to a list of hooks.</p><p>However, this is a teachable moment. Notice that when we called <code>add-hook</code> we called it for <code>xref-backend-functions</code>. If we tried to use the <code>:hook</code> keyword in <code>use-package</code>, because of an annoying architectural decision, you would get an error. The <code>use-package</code> macro, by default, assumes that when you say</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token lisp-property property">:hook</span> <span class="token punctuation">(</span><span class="token car">x-mode</span> <span class="token punctuation">.</span>  y-function<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>that you mean to attach a hook to <code>x-mode-hook</code>,</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token car">add-hook</span> <span class="token quoted-symbol variable symbol">&#39;x-mode-hook</span> <span class="token quoted-symbol variable symbol">&#39;y-function</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>because that is the convention. Well, sometimes, the convention is not followed, so you kinda have to use <code>:config</code>. Obviously this behaviour can be disabled by configuring <code>use-package</code> itself, but I think that <em>that</em> is an <strong>even worse</strong> architectural decision: <code>use-pacakge</code> forms must universally mean the same thing.</p><p>Now, you probably know that each major mode, conventionally provides a <code>hook</code> to be called once the major mode is fully loaded, but there are other useful hooks.</p><p><code>after-init-hook</code> is useful when you want to run a function after Emacs is instantiated. This is useful when you don&#39;t want to block the startup with an expensive function. <code>suspend-hook</code> is useful because it runs the function before Emacs is suspended, when you want Emacs to suspend. <code>kill-emacs-hook</code> is useful because it runs the function before Emacs is exited, when it is exited gracefully. Do with that information what you will, but I will caution against using these hooks extensively, without testing.</p><h3 id="the-bind-keyword" tabindex="-1"><a class="header-anchor" href="#the-bind-keyword"><span>The <code>:bind</code> keyword</span></a></h3><p>Suppose your package provides a function that is used far too frequently and randomly to be called from <code>M-x</code>. This is quite common. You can bind these functions to keys, using the <code>:bind</code> keyword.</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> avy</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:bind</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token string">&quot;C-l&quot;</span> <span class="token punctuation">.</span> avy-goto-word-0<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token string">&quot;M-l&quot;</span> <span class="token punctuation">.</span> avy-goto-char<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token string">&quot;M-g c&quot;</span> <span class="token punctuation">.</span> avy-goto-char<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token string">&quot;M-g M-g&quot;</span> <span class="token punctuation">.</span> avy-goto-line<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token string">&quot;M-g m&quot;</span> <span class="token punctuation">.</span> avy-pop-mark<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is a bit different from the previous keyword. Well, not quite, this kind of syntax without the overarching parenthesis is still accepted by the <code>use-package</code> macro. The main difference is that now, each line is evaluated sequentially, and added to a list of lists, just as before. Except now this list of lists is explicit. If you ever saw a documentation string that mentioned the dreadful <code>&amp;REST</code> this is what that looks like on the calling end.</p><p>The fun thing is that this is easy to understand and read, much more so than the <code>:config</code> form would be. Specifically,</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">(global-set-key (kbd &quot;C-l&quot;) &#39;avy-goto-word-0)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Notice, that it sets the key in the global key-map. This can be a problem, if the function that you&#39;re binding is dependent on a mode being activated.</p><p><code>avy</code> is a package that by all accounts should replace keyboard navigation. It has for me. It can operate in situations where no minor mode is enabled, and the function <code>avy-goto-word-0</code> is simply loaded, if and when the key combination <code>C-l</code> is invoked. Remember I told you that I think <code>use-package</code> is far superior to <code>lazy</code>, that&#39;s why. But sometimes, there must be other setup that needs to happen before a function can be invoked. The relationships are quite complicated, so it is usually a good idea to make use of another convention:</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"></span>
<span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> lsp-treemacs</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:bind</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token lisp-property property">:map</span> lsp-mode-map</span>
<span class="line">		<span class="token punctuation">(</span><span class="token string">&quot;C-`&quot;</span> <span class="token punctuation">.</span> lsp-treemacs-errors-list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is equivalent to</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token car">define-key</span> lsp-mode-map <span class="token punctuation">(</span><span class="token car">kbd</span> <span class="token string">&quot;C-\`&quot;</span> <span class="token quoted-symbol variable symbol">&#39;lsp-treemacs-errors-list</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>And this key binding is only valid, for as long as the <code>lsp-mode-map</code> is active. Meaning that if <code>lsp-mode</code> is disabled, this binding has no effect. The key combination does what other bindings specify and only overridden if and when <code>lsp-mode-map</code> is activated.</p><p>Incidentally, this form allows me to hit that convenient key to list all errors as reported by the resident Language server. This is quite equivalent to running <code>compile</code>, a built-in function but we will cover that in a separate topic.</p><p>I will assume that you know how to write key bindings, but just in case, if you need a complex key combination, angle brackets are your friend. If you end up adding a rogue space somewhere, <code>C-q</code> allows you to enter the character regardless of what it is bound to, and I <strong>strongly</strong> suggest never rebinding this key under any circumstances.</p><h3 id="the-custom-keyword" tabindex="-1"><a class="header-anchor" href="#the-custom-keyword"><span>The <code>:custom</code> keyword</span></a></h3><p>This is probably as advanced as you may need to go, anything more in-depth is probably best suited to a time when you&#39;re simply comfortable reading the README from the official GitHub. This piece of information can save you hours of debugging, so I recommend that you don&#39;t skip over it.</p><p>The final special case that is handled by its own keyword and for good reason is the <code>:custom</code> keyword and it interacts with the Emacs&#39; customisation user interface.</p><p>Long ago, it was envisioned that Emacs was a graphical text editor. Indeed, it still has many of the advantages of one, particularly when it comes to rendering multiple typefaces of different sizes and proportions, having graphical dialog windows, handling the <code>clipboard</code> in a civilised fashion, and many other things.</p><p>Before the GTK version became the predominant version of Emacs to be shipped, there was an attempt at creating a Graphical user interface with only Emacs Lisp and the text editing facilities. This gaves rise to many packages, some good, <em>e.g.</em> tetris, some bad, <em>e.g.</em> &quot;simple calculator&quot; and some which are just plain ugly, and unbecoming of a text editor with the legendary status that Emacs has achieved.</p><p>The <code>customize</code> interface is one such package, which sadly, became standard in Emacs. To invoke this, simply call <code>M-x customize</code> and it will present to you what looks like a sensible GUI, that is until you try to type text into what appears to be a text box. The only reason to ever touch it, is to find what customisable variables exist withing certain packages. But what constitutes a <code>customizable</code> variable. To put it simply, when you call <code>setq</code> on a variable, the only thing that can happen is the change in state of that particular variable. The changes propagate up until the functions that are invoked later that read that variable. In their infinite wisdom, the people designing Emacs, have decided that it is a great idea to institute another way to set those same variables, that will trigger other code to execute. The <code>customize</code> interface, will conveniently place any customised variable at the end of your <code>init.el</code>, for you to know what other differences between your regular out-of-the-box vanilla Emacs experience and your personalised experience exist.</p><p>It is perfectly acceptable to keep those variables in a giant block of symbolic expressions at the end of your init file. It is perfectly acceptable to even <code>setq</code> most of those variables instead of going through the <code>customize</code> interface. However, for the perfectionists among you, that see this as a grand violation of the celestial mechanics of Emacs, there is a specialised keyword, called <code>:custom</code> that accepts yet another form of argument.</p><div class="language-elisp line-numbers-mode" data-highlighter="prismjs" data-ext="elisp"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">use-package</span> eldoc</span>
<span class="line">  <span class="token lisp-property property">:ensure</span> <span class="token boolean">t</span></span>
<span class="line">  <span class="token lisp-property property">:custom</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">eldoc-documentation-strategy</span> <span class="token quoted-symbol variable symbol">&#39;eldoc-documentation-compose-eagerly</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">eldoc-echo-area-prefer-doc-buffer</span> <span class="token boolean">t</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">eldoc-idle-delay</span> <span class="token number">0.2</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token car">eldoc-minor-mode-string</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This simply put sets the variable on the left, to the value on the right. The keen eyed observer will see that there isn&#39;t a <code>.</code> in between the variables, that is because the <code>customize</code> function which is invoked here, can accept an optional third parameter in each list in the list of lists. That parameter is almost never used, because the only difference between it and a regular comment is that if the value is further changed via the <code>customize</code> interface, the interface itself will display that comment. Given that I would recommend only using <code>customize</code> for exploratory purposes, I don&#39;t find it particularly useful. Given the nature of Emacs it is universally better to read the source code for the package, and find the customisable variable, and then to decide what value is appropriate. It is not that when the authors provide meaningful choices, that having a drop-down menu is worse than typing the choice by hand; it&#39;s that most authors don&#39;t bother.</p><p>Truth be told, any difference between <code>setq</code> and <code>customize</code> is an anti-pattern, that relies on the assumption that a half-baked, semi textual interface is better than nothing. Technically, if utilised correctly, it would, allow people who not only don&#39;t know lisp, but no programming in general, to successfully use Emacs. If all the packages provided sensible customisation facilities, and that means proper documentation, proper formatting, proper choices, and frankly, proper channels to clarify some points without leaving the interface, I would say, let&#39;s deprecate <code>setq</code>. But, this is a half-feature that only half the community cares about and even fewer people want properly implemented in their own packages.</p><p>Creating an Elisp package is already a gargantuan task, for people that are essentially doing it with no compensation, this is a standard of practice that I&#39;m willing to let go.</p><h2 id="conclusion-when-to-use-package" tabindex="-1"><a class="header-anchor" href="#conclusion-when-to-use-package"><span>Conclusion: when to <code>use-package</code></span></a></h2><p>Honestly, I don&#39;t believe that <code>use-package</code> is a panacea, and that it should be applied indiscriminately to anyone&#39;s workflow. It is considered the industry standard, and there are good reasons, it automates and abstracts the concept of a package, it allows configuration to be local, and thanks to Emacs&#39; excellent editing facilities this means easy translation, refactoring, etc.</p><p>While it has its benefits, there are some key considerations to keep in mind, when you as a new user will decide on whether to make heavy use of this facility.</p><p>By avoiding the native Emacs lisp facilities for installing and using pacakges, you as a new user learn less. When I was getting started, <code>use-package</code> was already prevalent. As a consequence of never having to install a package manually, that is downloading the lisp files and extracting them to a place and then <code>require</code>-ing them, I&#39;ve missed out on quite a bit of organic learning. When I started writing my own Elisp, I found that I had not had the right exposure to the right concepts, and thus had trouble. In fact <code>use-pacakge</code>&#39;s keywords are the main reason why I had no idea that <code>global-set-key</code> was deprecated in favour of <code>keymap-global-set</code>. This seems small, but in hindsight it really does result in a large amount of re-learning that could have been subsumed into the configuration stage.</p><p>A slightly less important aspect of <code>use-package</code> is that you can not, mostly, see the functions that are being invoked. For example, you do not know the exact mechanics of what <code>:custom</code> does. You cannot differentiate between <code>custom-set-variable</code> and <code>customize-set-variable</code> unless you cheat and lookup.</p><p>Yet another problem, is that you cannot evaluate forms incrementally. Given that Emacs is unlike most modern development environments where &quot;dirty&quot; state is persisted, and the image of a machine can be different from a linear sequence of steps, you miss out on a lot. Batch processing is a standard, but largely because of convention, not because that approach is superior. In fact, incremental evaluation of nested code, allows one to build up complex functions much more rapidly and reliably, thanks to knowing exactly what each step is going to produce. This is not unlike the reason why it is customary to create plain-text streams between programs in a conventional UNIX shell script.</p><p>Finally, over-reliance on <code>use-package</code> has made it difficult for me to move on to other editors. I do not plan to remain an Emacsian forever. I find that it is worth exploring other ideas, and I would not be able to do that, if I were bound by the same limitations as Emacs imposes, even subliminally.</p><p>If I were just starting out, I would use <code>use-package</code> extensively to see what packages are available. But at the moment I had enough interest so as to write custom Emacs lisp (which comes later than you can imagine), you should drop <code>use-package</code> entirely, and attempt to replicate your workflow in a purely function and not macro-driven approach.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated:: </span><time class="meta-item-info" datetime="2025-03-23T16:53:28.000Z" data-allow-mismatch>23/03/2025, 16:53</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: ap886@cantab.ac.uk">Aleksandr Petrosyan</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-Cs446qsf.js" defer></script>
  </body>
</html>
